{
  "description": "Global p2p merkle-dag filesystem.",
  "subcommands": [
    {
      "subcommands": [],
      "options": [
        {
          "option": "--chunker",
          "shortcut": "-s",
          "description": "Chunking algorithm, size-[bytes], rabin-[min]-[avg]-[max] or buzhash. Files larger than chunk size are split into multiple blocks.",
          "value": "string",
          "default": "Import.UnixFSChunker"
        },
        {
          "option": "--cid-version",
          "description": "CID version (0 or 1). CIDv1 automatically enables raw-leaves and is required for non-sha2-256 hashes.",
          "value": "int",
          "default": "Import.CidVersion"
        },
        {
          "option": "--dereference-args",
          "description": "Symlinks supplied in arguments are dereferenced.",
          "value": "bool"
        },
        {
          "option": "--fast-provide-root",
          "description": "Immediately provide root CID to DHT in addition to regular queue, for faster discovery.",
          "value": "bool",
          "default": "Import.FastProvideRoot"
        },
        {
          "option": "--fast-provide-wait",
          "description": "Block until the immediate provide completes before returning.",
          "value": "bool",
          "default": "Import.FastProvideWait"
        },
        {
          "option": "--fscache",
          "description": "Check the filestore for pre-existing blocks.",
          "value": "bool"
        },
        {
          "option": "--hash",
          "description": "Hash function to use. Implies CIDv1 if not sha2-256.",
          "value": "string",
          "default": "Import.HashFunction"
        },
        {
          "option": "--hidden",
          "shortcut": "-H",
          "description": "Include files that are hidden. Only takes effect on recursive add.",
          "value": "bool"
        },
        {
          "option": "--ignore",
          "description": "A rule (.gitignore-style) defining which file(s) should be ignored (variadic, experimental).",
          "value": "array"
        },
        {
          "option": "--ignore-rules-path",
          "description": "A path to a file with .gitignore-style ignore rules (experimental).",
          "value": "string"
        },
        {
          "option": "--inline",
          "description": "Inline small blocks into CIDs. WARNING: experimental.",
          "value": "bool"
        },
        {
          "option": "--inline-limit",
          "description": "Maximum block size to inline. Maximum: 128 bytes. WARNING: experimental.",
          "value": "int",
          "default": "32"
        },
        {
          "option": "--max-directory-links",
          "description": "Limit the maximum number of links in UnixFS basic directory nodes to this value. WARNING: experimental.",
          "value": "int",
          "default": "Import.UnixFSDirectoryMaxLinks"
        },
        {
          "option": "--max-file-links",
          "description": "Limit the maximum number of links in UnixFS file nodes to this value. WARNING: experimental.",
          "value": "int",
          "default": "Import.UnixFSFileMaxLinks"
        },
        {
          "option": "--max-hamt-fanout",
          "description": "Limit the maximum number of links of a UnixFS HAMT directory node to this (power of 2, multiple of 8). WARNING: experimental.",
          "value": "int",
          "default": "Import.UnixFSHAMTDirectoryMaxFanout"
        },
        {
          "option": "--mode",
          "description": "Custom POSIX file mode to store in created UnixFS entries. WARNING: experimental.",
          "value": "uint"
        },
        {
          "option": "--mtime",
          "description": "Custom POSIX modification time to store in created UnixFS entries (seconds before or after the Unix Epoch). WARNING: experimental.",
          "value": "int64"
        },
        {
          "option": "--mtime-nsecs",
          "description": "Custom POSIX modification time (optional time fraction in nanoseconds).",
          "value": "uint"
        },
        {
          "option": "--nocopy",
          "description": "Add the file using filestore. Implies raw-leaves. WARNING: experimental.",
          "value": "bool"
        },
        {
          "option": "--pin",
          "description": "Pin locally to protect added files from garbage collection.",
          "value": "bool",
          "default": "true"
        },
        {
          "option": "--pin-name",
          "description": "Name to use for the pin. Requires explicit value (e.g., --pin-name=myname).",
          "value": "string"
        },
        {
          "option": "--preserve-mode",
          "description": "Apply existing POSIX permissions to created UnixFS entries. WARNING: experimental.",
          "value": "bool"
        },
        {
          "option": "--preserve-mtime",
          "description": "Apply existing POSIX modification time to created UnixFS entries. WARNING: experimental.",
          "value": "bool"
        },
        {
          "option": "--progress",
          "shortcut": "-p",
          "description": "Stream progress data.",
          "value": "bool"
        },
        {
          "option": "--quieter",
          "shortcut": "-Q",
          "description": "Write only final hash.",
          "value": "bool"
        },
        {
          "option": "--quiet",
          "shortcut": "-q",
          "description": "Write minimal output.",
          "value": "bool"
        },
        {
          "option": "--raw-leaves",
          "description": "Use raw blocks for leaf nodes. Note: CIDv1 automatically enables raw-leaves.",
          "value": "bool",
          "default": "false for CIDv0, true for CIDv1"
        },
        {
          "option": "--silent",
          "description": "Write no output.",
          "value": "bool"
        },
        {
          "option": "--to-files",
          "description": "Add reference to Files API (MFS) at the provided path.",
          "value": "string"
        },
        {
          "option": "--trickle",
          "shortcut": "-t",
          "description": "Use trickle-dag format for dag generation.",
          "value": "bool"
        },
        {
          "option": "--wrap-with-directory",
          "shortcut": "-w",
          "description": "Wrap files with a directory object.",
          "value": "bool"
        }
      ],
      "name": "ipfs add",
      "raw_help_text": "USAGE\n  ipfs add <path>... - Add a file or directory to IPFS.\n\nSYNOPSIS\n  ipfs add [--recursive | -r] [--dereference-args] [--stdin-name=<stdin-name>]\n           [--hidden | -H] [--ignore=<ignore>]...\n           [--ignore-rules-path=<ignore-rules-path>] [--quiet | -q]\n           [--quieter | -Q] [--silent] [--progress | -p] [--only-hash | -n]\n           [--wrap-with-directory | -w] [--pin=false] [--pin-name=<pin-name>]\n           [--to-files=<to-files>] [--cid-version=<cid-version>] [--hash=<hash>]\n           [--raw-leaves] [--chunker=<chunker> | -s] [--trickle | -t]\n           [--max-file-links=<max-file-links>]\n           [--max-directory-links=<max-directory-links>]\n           [--max-hamt-fanout=<max-hamt-fanout>] [--inline]\n           [--inline-limit=<inline-limit>] [--nocopy] [--fscache]\n           [--preserve-mode] [--preserve-mtime] [--mode=<mode>]\n           [--mtime=<mtime>] [--mtime-nsecs=<mtime-nsecs>] [--fast-provide-root]\n           [--fast-provide-wait] [--] <path>...\n\nARGUMENTS\n\n  <path>... - The path to a file to be added to IPFS.\n\nOPTIONS\n\n  -r, --recursive            bool   - Add directory paths recursively.\n  --dereference-args         bool   - Symlinks supplied in arguments are\n                                      dereferenced.\n  --stdin-name               string - Assign a name if the file source is stdin.\n  -H, --hidden               bool   - Include files that are hidden. Only takes\n                                      effect on recursive add.\n  --ignore                   array  - A rule (.gitignore-stype) defining which\n                                      file(s) should be ignored (variadic,\n                                      experimental).\n  --ignore-rules-path        string - A path to a file with .gitignore-style\n                                      ignore rules (experimental).\n  -q, --quiet                bool   - Write minimal output.\n  -Q, --quieter              bool   - Write only final hash.\n  --silent                   bool   - Write no output.\n  -p, --progress             bool   - Stream progress data.\n  -n, --only-hash            bool   - Only chunk and hash - do not write to\n                                      disk.\n  -w, --wrap-with-directory  bool   - Wrap files with a directory object.\n  --pin                      bool   - Pin locally to protect added files from\n                                      garbage collection. Default: true.\n  --pin-name                 string - Name to use for the pin. Requires\n                                      explicit value (e.g., --pin-name=myname).\n  --to-files                 string - Add reference to Files API (MFS) at the\n                                      provided path.\n  --cid-version              int    - CID version (0 or 1). CIDv1 automatically\n                                      enables raw-leaves and is required for\n                                      non-sha2-256 hashes. Default:\n                                      Import.CidVersion.\n  --hash                     string - Hash function to use. Implies CIDv1 if\n                                      not sha2-256. Default:\n                                      Import.HashFunction.\n  --raw-leaves               bool   - Use raw blocks for leaf nodes. Note:\n                                      CIDv1 automatically enables raw-leaves.\n                                      Default: false for CIDv0, true for CIDv1\n                                      (Import.UnixFSRawLeaves).\n  -s, --chunker              string - Chunking algorithm, size-[bytes],\n                                      rabin-[min]-[avg]-[max] or buzhash. Files\n                                      larger than chunk size are split into\n                                      multiple blocks. Default:\n                                      Import.UnixFSChunker.\n  -t, --trickle              bool   - Use trickle-dag format for dag generation.\n  --max-file-links           int    - Limit the maximum number of links in\n                                      UnixFS file nodes to this value. WARNING:\n                                      experimental. Default:\n                                      Import.UnixFSFileMaxLinks.\n  --max-directory-links      int    - Limit the maximum number of links in\n                                      UnixFS basic directory nodes to this\n                                      value. WARNING: experimental,\n                                      Import.UnixFSHAMTDirectorySizeThreshold\n                                      is safer. Default:\n                                      Import.UnixFSDirectoryMaxLinks.\n  --max-hamt-fanout          int    - Limit the maximum number of links of a\n                                      UnixFS HAMT directory node to this (power\n                                      of 2, multiple of 8). WARNING:\n                                      experimental,\n                                      Import.UnixFSHAMTDirectorySizeThreshold\n                                      is safer. Default:\n                                      Import.UnixFSHAMTDirectoryMaxFanout.\n  --inline                   bool   - Inline small blocks into CIDs. WARNING:\n                                      experimental.\n  --inline-limit             int    - Maximum block size to inline. Maximum:\n                                      128 bytes. WARNING: experimental.\n                                      Default: 32.\n  --nocopy                   bool   - Add the file using filestore. Implies\n                                      raw-leaves. WARNING: experimental.\n  --fscache                  bool   - Check the filestore for pre-existing\n                                      blocks. WARNING: experimental.\n  --preserve-mode            bool   - Apply existing POSIX permissions to\n                                      created UnixFS entries. WARNING:\n                                      experimental, forces dag-pb for root\n                                      block, disables raw-leaves.\n  --preserve-mtime           bool   - Apply existing POSIX modification time to\n                                      created UnixFS entries. WARNING:\n                                      experimental, forces dag-pb for root\n                                      block, disables raw-leaves.\n  --mode                     uint   - Custom POSIX file mode to store in\n                                      created UnixFS entries. WARNING:\n                                      experimental, forces dag-pb for root\n                                      block, disables raw-leaves.\n  --mtime                    int64  - Custom POSIX modification time to store\n                                      in created UnixFS entries (seconds before\n                                      or after the Unix Epoch). WARNING:\n                                      experimental, forces dag-pb for root\n                                      block, disables raw-leaves.\n  --mtime-nsecs              uint   - Custom POSIX modification time (optional\n                                      time fraction in nanoseconds).\n  --fast-provide-root        bool   - Immediately provide root CID to DHT in\n                                      addition to regular queue, for faster\n                                      discovery. Default:\n                                      Import.FastProvideRoot.\n  --fast-provide-wait        bool   - Block until the immediate provide\n                                      completes before returning. Default:\n                                      Import.FastProvideWait.\n\nDESCRIPTION\n\n  Adds the content of <path> to IPFS. Use -r to add directories.\n  Note that directories are added recursively, and big files are chunked,\n  to form the IPFS MerkleDAG. Learn more: https://docs.ipfs.tech/concepts/merkle-dag/\n  \n  If the daemon is not running, it will just add locally to the repo at $IPFS_PATH.\n  If the daemon is started later, it will be advertised after a few\n  seconds when the provide system runs.\n  \n  BASIC EXAMPLES:\n  \n  The wrap option, '-w', wraps the file (or files, if using the\n  recursive option) in a directory. This directory contains only\n  the files which have been added, and means that the file retains\n  its filename. For example:\n  \n    > ipfs add example.jpg\n    added QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH example.jpg\n    > ipfs add example.jpg -w\n    added QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH example.jpg\n    added QmaG4FuMqEBnQNn3C8XJ5bpW8kLs7zq2ZXgHptJHbKDDVx\n  \n  You can now refer to the added file in a gateway, like so:\n  \n    /ipfs/QmaG4FuMqEBnQNn3C8XJ5bpW8kLs7zq2ZXgHptJHbKDDVx/example.jpg\n  \n  Files imported with 'ipfs add' are protected from GC (implicit '--pin=true'),\n  but it is up to you to remember the returned CID to get the data back later.\n  \n  If you need to back up or transport content-addressed data using a non-IPFS\n  medium, CID can be preserved with CAR files.\n  See 'dag export' and 'dag import' for more information.\n  \n  MFS INTEGRATION:\n  \n  Passing '--to-files' creates a reference in Files API (MFS), making it easier\n  to find it in the future:\n  \n    > ipfs files mkdir -p /myfs/dir\n    > ipfs add example.jpg --to-files /myfs/dir/\n    > ipfs files ls /myfs/dir/\n    example.jpg\n  \n  See 'ipfs files --help' to learn more about using MFS\n  for keeping track of added files and directories.\n  \n  CHUNKING EXAMPLES:\n  \n  The chunker option, '-s', specifies the chunking strategy that dictates\n  how to break files into blocks. Blocks with same content can\n  be deduplicated. Different chunking strategies will produce different\n  hashes for the same file. The default is a fixed block size of\n  256 * 1024 bytes, 'size-262144'. Alternatively, you can use the\n  Buzhash or Rabin fingerprint chunker for content defined chunking by\n  specifying buzhash or rabin-[min]-[avg]-[max] (where min/avg/max refer\n  to the desired chunk sizes in bytes), e.g. 'rabin-262144-524288-1048576'.\n  \n  The following examples use very small byte sizes to demonstrate the\n  properties of the different chunkers on a small file. You'll likely\n  want to use a 1024 times larger chunk sizes for most files.\n  \n    > ipfs add --chunker=size-2048 ipfs-logo.svg\n    added QmafrLBfzRLV4XSH1XcaMMeaXEUhDJjmtDfsYU95TrWG87 ipfs-logo.svg\n    > ipfs add --chunker=rabin-512-1024-2048 ipfs-logo.svg\n    added Qmf1hDN65tR55Ubh2RN1FPxr69xq3giVBz1KApsresY8Gn ipfs-logo.svg\n  \n  You can now check what blocks have been created by:\n  \n    > ipfs ls QmafrLBfzRLV4XSH1XcaMMeaXEUhDJjmtDfsYU95TrWG87\n    QmY6yj1GsermExDXoosVE3aSPxdMNYr6aKuw3nA8LoWPRS 2059\n    Qmf7ZQeSxq2fJVJbCmgTrLLVN9tDR9Wy5k75DxQKuz5Gyt 1195\n    > ipfs ls Qmf1hDN65tR55Ubh2RN1FPxr69xq3giVBz1KApsresY8Gn\n    QmY6yj1GsermExDXoosVE3aSPxdMNYr6aKuw3nA8LoWPRS 2059\n    QmerURi9k4XzKCaaPbsK6BL5pMEjF7PGphjDvkkjDtsVf3 868\n    QmQB28iwSriSUSMqG2nXDTLtdPHgWb4rebBrU7Q1j4vxPv 338\n  \n  ADVANCED CONFIGURATION:\n  \n  Finally, a note on hash (CID) determinism and 'ipfs add' command.\n  \n  Almost all the flags provided by this command will change the final CID, and\n  new flags may be added in the future. It is not guaranteed for the implicit\n  defaults of 'ipfs add' to remain the same in future Kubo releases, or for other\n  IPFS software to use the same import parameters as Kubo.\n  \n  Note: CIDv1 is automatically used when using non-default options like custom\n  hash functions or when raw-leaves is explicitly enabled.\n  \n  Use Import.* configuration options to override global implicit defaults:\n  https://github.com/ipfs/kubo/blob/master/docs/config.md#import",
      "description": "Add a file to IPFS"
    },
    {
      "name": "ipfs basic",
      "subcommands": [],
      "options": [],
      "description": "Basic command set"
    },
    {
      "description": "Interact with raw IPFS blocks.",
      "subcommands": [
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs block get",
          "raw_help_text": "USAGE\n  ipfs block get <cid> - Get a raw IPFS block.\n\nSYNOPSIS\n  ipfs block get [--] <cid>\n\nARGUMENTS\n\n  <cid> - The CID of an existing block to get.\n\nDESCRIPTION\n\n  'ipfs block get' is a plumbing command for retrieving raw IPFS blocks.\n  It takes a <cid>, and outputs the block to stdout.",
          "description": "Get a raw IPFS block."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--allow-big-block",
              "shortcut": null,
              "description": "Disable block size check and allow creation of blocks bigger than 1MiB. WARNING: such blocks won't be transferable over the standard bitswap.",
              "value": null,
              "default": "false"
            },
            {
              "option": "--cid-codec",
              "shortcut": null,
              "description": "Multicodec to use in returned CID.",
              "value": "string",
              "default": "raw"
            },
            {
              "option": "--format",
              "shortcut": "-f",
              "description": "Use legacy format for returned CID (DEPRECATED).",
              "value": "string",
              "default": null
            },
            {
              "option": "--mhlen",
              "shortcut": null,
              "description": "Multihash hash length.",
              "value": "int",
              "default": "-1"
            },
            {
              "option": "--mhtype",
              "shortcut": null,
              "description": "Multihash hash function.",
              "value": "string",
              "default": null
            },
            {
              "option": "--pin",
              "shortcut": null,
              "description": "Pin added blocks recursively.",
              "value": "bool",
              "default": "false"
            }
          ],
          "name": "ipfs block put",
          "raw_help_text": "USAGE\n  ipfs block put <data>... - Store input as an IPFS block.\n\nSYNOPSIS\n  ipfs block put [--cid-codec=<cid-codec>] [--mhtype=<mhtype>] [--mhlen=<mhlen>]\n                 [--pin] [--allow-big-block] [--format=<format> | -f] [--]\n                 <data>...\n\nARGUMENTS\n\n  <data>... - The data to be stored as an IPFS block.\n\nOPTIONS\n\n  --cid-codec        string - Multicodec to use in returned CID. Default: raw.\n  --mhtype           string - Multihash hash function.\n  --mhlen            int    - Multihash hash length. Default: -1.\n  --pin              bool   - Pin added blocks recursively. Default: false.\n  --allow-big-block  bool   - Disable block size check and allow creation of\n                              blocks bigger than 1MiB. WARNING: such blocks\n                              won't be transferable over the standard bitswap.\n                              Default: false.\n  -f, --format       string - Use legacy format for returned CID (DEPRECATED).\n\nDESCRIPTION\n\n  'ipfs block put' is a plumbing command for storing raw IPFS blocks.\n  It reads data from stdin, and outputs the block's CID to stdout.\n  \n  Unless cid-codec is specified, this command returns raw (0x55) CIDv1 CIDs.\n  \n  Passing alternative --cid-codec does not modify imported data, nor run any\n  validation. It is provided solely for convenience for users who create blocks\n  in userland.\n  \n  NOTE:\n  Do not use --format for any new code. It got superseded by --cid-codec and left\n  only for backward compatibility when a legacy CIDv0 is required (--format=v0).",
          "description": "Store input as an IPFS block."
        },
        {
          "description": "'ipfs block rm' is a plumbing command for removing raw ipfs blocks.",
          "subcommands": [],
          "options": [
            {
              "option": "--force",
              "shortcut": "-f",
              "description": "Ignore nonexistent blocks.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--quiet",
              "shortcut": "-q",
              "description": "Write minimal output.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs block rm",
          "raw_help_text": "USAGE\n  ipfs block rm <cid>... - Remove IPFS block(s) from the local datastore.\n\nSYNOPSIS\n  ipfs block rm [--force | -f] [--quiet | -q] [--] <cid>...\n\nARGUMENTS\n\n  <cid>... - CIDs of block(s) to remove.\n\nOPTIONS\n\n  -f, --force  bool - Ignore nonexistent blocks.\n  -q, --quiet  bool - Write minimal output.\n\nDESCRIPTION\n\n  'ipfs block rm' is a plumbing command for removing raw ipfs blocks.\n  It takes a list of CIDs to remove from the local datastore.."
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs block stat",
          "raw_help_text": "USAGE\n  ipfs block stat <cid> - Print information of a raw IPFS block.\n\nSYNOPSIS\n  ipfs block stat [--] <cid>\n\nARGUMENTS\n\n  <cid> - The CID of an existing block to stat.\n\nDESCRIPTION\n\n  'ipfs block stat' is a plumbing command for retrieving information\n  on raw IPFS blocks. It outputs the following to stdout:\n  \n  \tKey  - the CID of the block\n  \tSize - the size of the block in bytes",
          "description": "Print information of a raw IPFS block."
        }
      ],
      "options": [],
      "name": "ipfs block",
      "raw_help_text": "USAGE\n  ipfs block - Interact with raw IPFS blocks.\n\nSYNOPSIS\n  ipfs block\n\nDESCRIPTION\n\n  'ipfs block' is a plumbing command used to manipulate raw IPFS blocks.\n  Reads from stdin or writes to stdout. A block is identified by a Multihash\n  passed with a valid CID.\n\nSUBCOMMANDS\n  ipfs block get <cid>     - Get a raw IPFS block.\n  ipfs block put <data>... - Store input as an IPFS block.\n  ipfs block rm <cid>...   - Remove IPFS block(s) from the local datastore.\n  ipfs block stat <cid>    - Print information of a raw IPFS block.\n\n  For more information about each command, use:\n  'ipfs block <subcmd> --help'"
    },
    {
      "description": "Show or edit the list of bootstrap peers.",
      "subcommands": [
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs bootstrap add",
          "raw_help_text": "USAGE\n  ipfs bootstrap add [<peer>]... - Add peers to the bootstrap list.\n\nSYNOPSIS\n  ipfs bootstrap add [--] [<peer>...]\n\nARGUMENTS\n\n  [<peer>]... - A peer to add to the bootstrap list (in the format\n                '<multiaddr>/<peerID>')\n\nDESCRIPTION\n\n  Outputs a list of peers that were added (that weren't already\n  in the bootstrap list).\n  \n  The special values 'default' and 'auto' can be used to add the default\n  bootstrap peers. Both are equivalent and will add the 'auto' placeholder to\n  the bootstrap list, which gets resolved using the AutoConf system.\n  \n  SECURITY WARNING:\n  \n  The bootstrap command manipulates the \"bootstrap list\", which contains\n  the addresses of bootstrap nodes. These are the *trusted peers* from\n  which to learn about other peers in the network. Only edit this list\n  if you understand the risks of adding or removing nodes from this list.",
          "description": "Add peers to the bootstrap list."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--expand-auto",
              "shortcut": null,
              "description": "Expand 'auto' placeholders from AutoConf service.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs bootstrap list",
          "raw_help_text": "USAGE\n  ipfs bootstrap list - Show peers in the bootstrap list.\n\nSYNOPSIS\n  ipfs bootstrap list [--expand-auto]\n\nOPTIONS\n\n  --expand-auto  bool - Expand 'auto' placeholders from AutoConf service.\n\nDESCRIPTION\n\n  Peers are output in the format '<multiaddr>/<peerID>'.",
          "description": "Show peers in the bootstrap list."
        },
        {
          "subcommands": [
            {
              "subcommands": [],
              "options": [],
              "name": "ipfs bootstrap rm all",
              "raw_help_text": "USAGE\n  ipfs bootstrap rm all - Remove all peers from the bootstrap list.\n\nSYNOPSIS\n  ipfs bootstrap rm all\n\nDESCRIPTION\n\n  Outputs the list of peers that were removed.",
              "description": "Remove all peers from the bootstrap list."
            }
          ],
          "options": [
            {
              "option": "--all",
              "shortcut": null,
              "description": "Remove all bootstrap peers. (Deprecated, use 'all' subcommand).",
              "value": "bool",
              "default": null
            }
          ],
          "description": "Remove peers from the bootstrap list.",
          "name": "ipfs bootstrap rm",
          "raw_help_text": "USAGE\n  ipfs bootstrap rm [<peer>]... - Remove peers from the bootstrap list.\n\nSYNOPSIS\n  ipfs bootstrap rm [--all] [--] [<peer>...]\n\nARGUMENTS\n\n  [<peer>]... - A peer to add to the bootstrap list (in the format\n                '<multiaddr>/<peerID>')\n\nOPTIONS\n\n  --all  bool - Remove all bootstrap peers. (Deprecated, use 'all' subcommand).\n\nDESCRIPTION\n\n  Outputs the list of peers that were removed.\n  \n  SECURITY WARNING:\n  \n  The bootstrap command manipulates the \"bootstrap list\", which contains\n  the addresses of bootstrap nodes. These are the *trusted peers* from\n  which to learn about other peers in the network. Only edit this list\n  if you understand the risks of adding or removing nodes from this list.\n\nSUBCOMMANDS\n  ipfs bootstrap rm all - Remove all peers from the bootstrap list.\n\n  For more information about each command, use:\n  'ipfs bootstrap rm <subcmd> --help'"
        }
      ],
      "options": [],
      "name": "ipfs bootstrap",
      "raw_help_text": "USAGE\n  ipfs bootstrap - Show or edit the list of bootstrap peers.\n\nSYNOPSIS\n  ipfs bootstrap\n\nDESCRIPTION\n\n  Running 'ipfs bootstrap' with no arguments will run 'ipfs bootstrap list'.\n  \n  SECURITY WARNING:\n  \n  The bootstrap command manipulates the \"bootstrap list\", which contains\n  the addresses of bootstrap nodes. These are the *trusted peers* from\n  which to learn about other peers in the network. Only edit this list\n  if you understand the risks of adding or removing nodes from this list.\n\nSUBCOMMANDS\n  ipfs bootstrap add [<peer>]... - Add peers to the bootstrap list.\n  ipfs bootstrap list            - Show peers in the bootstrap list.\n  ipfs bootstrap rm [<peer>]...  - Remove peers from the bootstrap list.\n\n  For more information about each command, use:\n  'ipfs bootstrap <subcmd> --help'"
    },
    {
      "subcommands": [],
      "options": [
        {
          "option": "--offset",
          "shortcut": "-o",
          "description": "Byte offset to begin reading from.",
          "value": "<offset>",
          "default": null
        },
        {
          "option": "--length",
          "shortcut": "-l",
          "description": "Maximum number of bytes to read.",
          "value": "<length>",
          "default": null
        },
        {
          "option": "--progress",
          "shortcut": "-p",
          "description": "Stream progress data.",
          "value": "false",
          "default": "true"
        }
      ],
      "name": "ipfs cat",
      "raw_help_text": "USAGE\n  ipfs cat <ipfs-path>... - Show IPFS object data.\n\nSYNOPSIS\n  ipfs cat [--offset=<offset> | -o] [--length=<length> | -l] [--progress=false]\n           [--] <ipfs-path>...\n\nARGUMENTS\n\n  <ipfs-path>... - The path to the IPFS object(s) to be outputted.\n\nOPTIONS\n\n  -o, --offset    int64 - Byte offset to begin reading from.\n  -l, --length    int64 - Maximum number of bytes to read.\n  -p, --progress  bool  - Stream progress data. Default: true.\n\nDESCRIPTION\n\n  Displays the data contained by an IPFS or IPNS object(s) at the given path.",
      "description": "Show IPFS object data"
    },
    {
      "description": "Get and set IPFS config values.",
      "subcommands": [
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs config edit",
          "raw_help_text": "USAGE\n  ipfs config edit - Open the config file for editing in $EDITOR.\n\nSYNOPSIS\n  ipfs config edit\n\nDESCRIPTION\n\n  To use 'ipfs config edit', you must have the $EDITOR environment\n  variable set to your preferred text editor.",
          "description": "Open the config file for editing in $EDITOR."
        },
        {
          "subcommands": [
            {
              "subcommands": [],
              "options": [
                {
                  "option": "--dry-run",
                  "shortcut": null,
                  "description": "print difference between the current config and the config that would be generated.",
                  "value": "bool",
                  "default": null
                }
              ],
              "name": "ipfs config profile apply",
              "raw_help_text": "USAGE\n  ipfs config profile apply <profile> - Apply profile to config.\n\nSYNOPSIS\n  ipfs config profile apply [--dry-run] [--] <profile>\n\nARGUMENTS\n\n  <profile> - The profile to apply to the config.\n\nOPTIONS\n\n  --dry-run  bool - print difference between the current config and the config\n                    that would be generated.",
              "description": "Apply profile to config."
            }
          ],
          "options": [],
          "name": "ipfs config profile",
          "raw_help_text": "USAGE\n  ipfs config profile - Apply profiles to config.\n\nSYNOPSIS\n  ipfs config profile\n\nDESCRIPTION\n\n  Available profiles:\n    'announce-off':\n      Disables Provide system (announcing to Amino DHT).\n      \n      \t\tUSE WITH CAUTION:\n      \t\tThe main use case for this is setups with manual Peering.Peers config.\n      \t\tData from this node will not be announced on the DHT. This will make\n      \t\tDHT-based routing and data retrieval impossible if this node is the only\n      \t\tone hosting it, and other peers are not already connected to it.\n      \n    'announce-on':\n      Re-enables Provide system (reverts announce-off profile).\n    'autoconf-off':\n      Disables AutoConf and sets networking fields to empty for manual configuration.\n      Bootstrap peers, DNS resolvers, delegated routers, and IPNS delegated publishers are set to empty.\n      Use this when you want normal networking but prefer manual control over all endpoints.\n    'autoconf-on':\n      Sets configuration to use implicit defaults from remote autoconf service.\n      Bootstrap peers, DNS resolvers, delegated routers, and IPNS delegated publishers are set to \"auto\".\n      This profile requires AutoConf to be enabled and configured.\n    'badgerds':\n      Configures the node to use the legacy badgerv1 datastore.\n      \n      NOTE: this is badger 1.x, which has known bugs and is no longer supported by the upstream team.\n      It is provided here only for pre-existing users, allowing them to migrate away to more modern datastore.\n      \n      Other caveats:\n      \n      * This datastore will not properly reclaim space when your datastore is\n        smaller than several gigabytes.  If you run IPFS with --enable-gc, you plan\n        on storing very little data in your IPFS node, and disk usage is more\n        critical than performance, consider using flatfs.\n      * This datastore uses up to several gigabytes of memory.\n      * Good for medium-size datastores, but may run into performance issues\n        if your dataset is bigger than a terabyte.\n      \n      See configuration documentation at:\n      https://github.com/ipfs/kubo/blob/master/docs/datastores.md#badgerds\n      \n      NOTE: This profile may only be applied when first initializing node at IPFS_PATH\n            via 'ipfs init --profile badgerds'\n      \n    'badgerds-measure':\n      Configures the node to use the legacy badgerv1 datastore with metrics wrapper.\n      Additional '*_datastore_*' metrics will be exposed on /debug/metrics/prometheus\n      \n      NOTE: This profile may only be applied when first initializing node at IPFS_PATH\n            via 'ipfs init --profile badgerds-measure'\n      \n    'default-datastore':\n      Configures the node to use the default datastore (flatfs).\n      \n      Read the \"flatfs\" profile description for more information on this datastore.\n      \n      This profile may only be applied when first initializing the node.\n      \n    'default-networking':\n      Restores default network settings.\n      Inverse profile of the test profile.\n    'flatfs':\n      Configures the node to use the flatfs datastore.\n      \n      This is the most battle-tested and reliable datastore.\n      You should use this datastore if:\n      \n      * You need a very simple and very reliable datastore, and you trust your\n        filesystem. This datastore stores each block as a separate file in the\n        underlying filesystem so it's unlikely to loose data unless there's an issue\n        with the underlying file system.\n      * You need to run garbage collection in a way that reclaims free space as soon as possible.\n      * You want to minimize memory usage.\n      * You are ok with the default speed of data import, or prefer to use --nocopy.\n      \n      See configuration documentation at:\n      https://github.com/ipfs/kubo/blob/master/docs/datastores.md#flatfs\n      \n      NOTE: This profile may only be applied when first initializing node at IPFS_PATH\n            via 'ipfs init --profile flatfs'\n      \n    'flatfs-measure':\n      Configures the node to use the flatfs datastore with metrics tracking wrapper.\n      Additional '*_datastore_*' metrics will be exposed on /debug/metrics/prometheus\n      \n      NOTE: This profile may only be applied when first initializing node at IPFS_PATH\n            via 'ipfs init --profile flatfs-measure'\n      \n    'legacy-cid-v0':\n      Makes UnixFS import produce legacy CIDv0 with no raw leaves, sha2-256 and 256 KiB chunks. This is likely the least optimal preset, use only if legacy behavior is required.\n    'local-discovery':\n      Sets default values to fields affected by the server\n      profile, enables discovery in local networks.\n    'lowpower':\n      Reduces daemon overhead on the system. May affect node\n      functionality - performance of content discovery and data\n      fetching may be degraded.\n      \n    'pebbleds':\n      Configures the node to use the pebble high-performance datastore.\n      \n      Pebble is a LevelDB/RocksDB inspired key-value store focused on performance\n      and internal usage by CockroachDB.\n      You should use this datastore if:\n      \n      - You need a datastore that is focused on performance.\n      - You need reliability by default, but may choose to disable WAL for maximum performance when reliability is not critical.\n      - This datastore is good for multi-terabyte data sets.\n      - May benefit from tuning depending on read/write patterns and throughput.\n      - Performance is helped significantly by running on a system with plenty of memory.\n      \n      See configuration documentation at:\n      https://github.com/ipfs/kubo/blob/master/docs/datastores.md#pebbleds\n      \n      NOTE: This profile may only be applied when first initializing node at IPFS_PATH\n            via 'ipfs init --profile pebbleds'\n      \n    'pebbleds-measure':\n      Configures the node to use the pebble datastore with metrics tracking wrapper.\n      Additional '*_datastore_*' metrics will be exposed on /debug/metrics/prometheus\n      \n      NOTE: This profile may only be applied when first initializing node at IPFS_PATH\n            via 'ipfs init --profile pebbleds-measure'\n      \n    'randomports':\n      Use a random port number for swarm.\n    'server':\n      Disables local host discovery, recommended when\n      running IPFS on machines with public IPv4 addresses.\n    'test':\n      Reduces external interference of IPFS daemon, this\n      is useful when using the daemon in test environments.\n    'test-cid-v1':\n      Makes UnixFS import produce CIDv1 with raw leaves, sha2-256 and 1 MiB chunks (max 174 links per file, 256 per HAMT node, switch dir to HAMT above 256KiB).\n    'test-cid-v1-wide':\n      Makes UnixFS import produce CIDv1 with raw leaves, sha2-256 and 1MiB chunks and wider file DAGs (max 1024 links per every node type, switch dir to HAMT above 1MiB).\n\nSUBCOMMANDS\n  ipfs config profile apply <profile> - Apply profile to config.\n\n  For more information about each command, use:\n  'ipfs config profile <subcmd> --help'",
          "description": "Apply profiles to config."
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs config replace",
          "raw_help_text": "USAGE\n  ipfs config replace <file> - Replace the config with <file>.\n\nSYNOPSIS\n  ipfs config replace [--] <file>\n\nARGUMENTS\n\n  <file> - The file to use as the new config.\n\nDESCRIPTION\n\n  Make sure to back up the config file first if necessary, as this operation\n  can't be undone.",
          "description": "Replace the config with <file>."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--help",
              "shortcut": "-h",
              "description": "Show help information",
              "value": null,
              "default": null
            }
          ],
          "description": "Output config file contents.",
          "name": "ipfs config show",
          "raw_help_text": "USAGE\n  ipfs config show - Output config file contents.\n\nSYNOPSIS\n  ipfs config show\n\nDESCRIPTION\n\n  NOTE: For security reasons, this command will omit your private key and remote services. If you would like to make a full backup of your config (private key included), you must copy the config file from your repo."
        }
      ],
      "options": [
        {
          "option": "--bool",
          "shortcut": null,
          "description": "Set a boolean value.",
          "value": "bool",
          "default": null
        },
        {
          "option": "--expand-auto",
          "shortcut": null,
          "description": "Expand 'auto' placeholders to their expanded values from AutoConf service.",
          "value": "bool",
          "default": null
        },
        {
          "option": "--json",
          "shortcut": null,
          "description": "Parse stringified JSON.",
          "value": "bool",
          "default": null
        }
      ],
      "name": "ipfs config",
      "raw_help_text": "USAGE\n  ipfs config <key> [<value>] - Get and set IPFS config values.\n\nSYNOPSIS\n  ipfs config [--bool] [--json] [--expand-auto] [--] <key> [<value>]\n\nARGUMENTS\n\n  <key>     - The key of the config entry (e.g. \"Addresses.API\").\n  [<value>] - The value to set the config entry to.\n\nOPTIONS\n\n  --bool         bool - Set a boolean value.\n  --json         bool - Parse stringified JSON.\n  --expand-auto  bool - Expand 'auto' placeholders to their expanded values\n                        from AutoConf service.\n\nDESCRIPTION\n\n  'ipfs config' controls configuration variables. It works\n  much like 'git config'. The configuration values are stored in a config\n  file inside your IPFS repository (IPFS_PATH).\n  \n  Examples:\n  \n  Get the value of the 'Routing.Type' key:\n  \n    $ ipfs config Routing.Type\n  \n  Set the value of the 'Routing.Type' key:\n  \n    $ ipfs config Routing.Type auto\n  \n  Set multiple values in the 'Addresses.AppendAnnounce' array:\n  \n    $ ipfs config Addresses.AppendAnnounce --json \\\n        '[\"/dns4/a.example.com/tcp/4001\", \"/dns4/b.example.com/tcp/4002\"]'\n\nSUBCOMMANDS\n  ipfs config edit           - Open the config file for editing in $EDITOR.\n  ipfs config profile        - Apply profiles to config.\n  ipfs config replace <file> - Replace the config with <file>.\n  ipfs config show           - Output config file contents.\n\n  For more information about each command, use:\n  'ipfs config <subcmd> --help'"
    },
    {
      "command": {
        "description": "Run a network-connected IPFS node.",
        "subcommands": [],
        "options": [
          {
            "option": "--agent-version-suffix",
            "shortcut": null,
            "description": "Optional suffix to the AgentVersion presented by `ipfs id` and exposed via libp2p identify protocol.",
            "value": "<agent-version-suffix>",
            "default": null
          },
          {
            "option": "--disable-transport-encryption",
            "shortcut": null,
            "description": "Disable transport encryption (for debugging protocols).",
            "value": null,
            "default": null
          },
          {
            "option": "--enable-gc",
            "shortcut": null,
            "description": "Enable automatic periodic repo garbage collection.",
            "value": null,
            "default": null
          },
          {
            "option": "--enable-mplex-experiment",
            "shortcut": null,
            "description": "DEPRECATED.",
            "value": null,
            "default": null
          },
          {
            "option": "--enable-namesys-pubsub",
            "shortcut": null,
            "description": "Enable IPNS over pubsub. Implicitly enables pubsub, overrides Ipns.UsePubsub config.",
            "value": null,
            "default": null
          },
          {
            "option": "--enable-pubsub-experiment",
            "shortcut": null,
            "description": "DEPRECATED.",
            "value": null,
            "default": null
          },
          {
            "option": "--init",
            "shortcut": null,
            "description": "Initialize Kubo with default settings if not already initialized.",
            "value": null,
            "default": null
          },
          {
            "option": "--init-config",
            "shortcut": null,
            "description": "Path to existing configuration file to be loaded during --init.",
            "value": "<init-config>",
            "default": null
          },
          {
            "option": "--init-profile",
            "shortcut": null,
            "description": "Configuration profiles to apply for --init. See ipfs init --help for more.",
            "value": "<init-profile>",
            "default": null
          },
          {
            "option": "--manage-fdlimit",
            "shortcut": null,
            "description": "Check and raise file descriptor limits if needed.",
            "value": "false",
            "default": "true"
          },
          {
            "option": "--migrate",
            "shortcut": null,
            "description": "If true, assume yes at the migrate prompt. If false, assume no.",
            "value": null,
            "default": null
          },
          {
            "option": "--mount",
            "shortcut": null,
            "description": "Mounts IPFS to the filesystem using FUSE (experimental).",
            "value": null,
            "default": null
          },
          {
            "option": "--mount-ipfs",
            "shortcut": null,
            "description": "Path to the mountpoint for IPFS (if using --mount). Defaults to config setting.",
            "value": "<mount-ipfs>",
            "default": null
          },
          {
            "option": "--mount-ipns",
            "shortcut": null,
            "description": "Path to the mountpoint for IPNS (if using --mount). Defaults to config setting.",
            "value": "<mount-ipns>",
            "default": null
          },
          {
            "option": "--mount-mfs",
            "shortcut": null,
            "description": "Path to the mountpoint for MFS (if using --mount). Defaults to config setting.",
            "value": "<mount-mfs>",
            "default": null
          },
          {
            "option": "--routing",
            "shortcut": null,
            "description": "Overrides the routing option.",
            "value": "default",
            "default": null
          },
          {
            "option": "--unrestricted-api",
            "shortcut": null,
            "description": "Allow RPC API access to unlisted hashes.",
            "value": null,
            "default": null
          }
        ]
      },
      "name": "ipfs daemon",
      "raw_help_text": "USAGE\n  ipfs daemon - Run a network-connected IPFS node.\n\nSYNOPSIS\n  ipfs daemon [--init] [--init-config=<init-config>]\n              [--init-profile=<init-profile>] [--routing=<routing>] [--mount]\n              [--mount-ipfs=<mount-ipfs>] [--mount-ipns=<mount-ipns>]\n              [--mount-mfs=<mount-mfs>] [--unrestricted-api]\n              [--disable-transport-encryption] [--enable-gc]\n              [--manage-fdlimit=false] [--migrate] [--enable-pubsub-experiment]\n              [--enable-namesys-pubsub] [--enable-mplex-experiment]\n              [--agent-version-suffix=<agent-version-suffix>]\n\nOPTIONS\n\n  --init                          bool   - Initialize Kubo with default\n                                           settings if not already initialized.\n  --init-config                   string - Path to existing configuration file\n                                           to be loaded during --init.\n  --init-profile                  string - Configuration profiles to apply for\n                                           --init. See ipfs init --help for\n                                           more.\n  --routing                       string - Overrides the routing option.\n                                           Default: default.\n  --mount                         bool   - Mounts IPFS to the filesystem using\n                                           FUSE (experimental).\n  --mount-ipfs                    string - Path to the mountpoint for IPFS (if\n                                           using --mount). Defaults to config\n                                           setting.\n  --mount-ipns                    string - Path to the mountpoint for IPNS (if\n                                           using --mount). Defaults to config\n                                           setting.\n  --mount-mfs                     string - Path to the mountpoint for MFS (if\n                                           using --mount). Defaults to config\n                                           setting.\n  --unrestricted-api              bool   - Allow RPC API access to unlisted\n                                           hashes.\n  --disable-transport-encryption  bool   - Disable transport encryption (for\n                                           debugging protocols).\n  --enable-gc                     bool   - Enable automatic periodic repo\n                                           garbage collection.\n  --manage-fdlimit                bool   - Check and raise file descriptor\n                                           limits if needed. Default: true.\n  --migrate                       bool   - If true, assume yes at the migrate\n                                           prompt. If false, assume no.\n  --enable-pubsub-experiment      bool   - DEPRECATED.\n  --enable-namesys-pubsub         bool   - Enable IPNS over pubsub. Implicitly\n                                           enables pubsub, overrides\n                                           Ipns.UsePubsub config.\n  --enable-mplex-experiment       bool   - DEPRECATED.\n  --agent-version-suffix          string - Optional suffix to the AgentVersion\n                                           presented by `ipfs id` and exposed\n                                           via libp2p identify protocol.\n\nDESCRIPTION\n\n  The Kubo daemon will start listening on ports on the network, which are\n  documented in (and can be modified through) 'ipfs config Addresses'.\n  For example, to change the 'Gateway' port:\n  \n    ipfs config Addresses.Gateway /ip4/127.0.0.1/tcp/8082\n  \n  The RPC API address can be changed the same way:\n  \n    ipfs config Addresses.API /ip4/127.0.0.1/tcp/5002\n  \n  Make sure to restart the daemon after changing addresses.\n  \n  By default, the gateway is only accessible locally. To expose it to\n  other computers in the network, use 0.0.0.0 as the ip address:\n  \n    ipfs config Addresses.Gateway /ip4/0.0.0.0/tcp/8080\n  \n  Be careful if you expose the RPC API. It is a security risk, as anyone could\n  control your node remotely. If you need to control the node remotely,\n  make sure to protect the port as you would other services or database\n  (firewall, authenticated proxy, etc), or at least set API.Authorizations.\n  \n  If you do not want to open any ports for RPC, and only want to use\n  kubo CLI client, it is possible to expose the RPC over Unix socket:\n  \n    ipfs config Addresses.API /unix/var/run/kubo.socket\n  \n  HTTP Headers\n  \n  Kubo supports passing arbitrary headers to the RPC API and Gateway. You can\n  do this by setting headers on the API.HTTPHeaders and Gateway.HTTPHeaders\n  keys:\n  \n    ipfs config --json API.HTTPHeaders.X-Special-Header \"[\\\"so special :)\\\"]\"\n    ipfs config --json Gateway.HTTPHeaders.X-Special-Header \"[\\\"so special :)\\\"]\"\n  \n  Note that the value of the keys is an _array_ of strings. This is because\n  headers can have more than one value, and it is convenient to pass through\n  to other libraries.\n  \n  CORS Headers (for RPC API)\n  \n  You can setup CORS headers the same way:\n  \n    ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin \"[\\\"example.com\\\"]\"\n    ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods \"[\\\"PUT\\\", \\\"GET\\\", \\\"POST\\\"]\"\n    ipfs config --json API.HTTPHeaders.Access-Control-Allow-Credentials \"[\\\"true\\\"]\"\n  \n  Shutdown\n  \n  To shut down the daemon, send a SIGINT signal to it (e.g. by pressing 'Ctrl-C')\n  or send a SIGTERM signal to it (e.g. with 'kill'). It may take a while for the\n  daemon to shutdown gracefully, but it can be killed forcibly by sending a\n  second signal.\n  \n  IPFS_PATH environment variable\n  \n  Kubo uses a repository in the local file system. By default, the repo is\n  located at ~/.ipfs. To change the repo location, set the $IPFS_PATH\n  environment variable:\n  \n    export IPFS_PATH=/path/to/ipfsrepo\n  \n  DEPRECATION NOTICE\n  \n  Previously, Kubo used an environment variable as seen below:\n  \n    export API_ORIGIN=\"http://localhost:8888/\"\n  \n  This is deprecated. It is still honored in this version, but will be removed\n  in a future version, along with this notice. Please move to setting the HTTP\n  Headers.",
      "subcommands": [],
      "description": "Start a long-running daemon process"
    },
    {
      "description": "Interact with IPLD DAG objects.",
      "subcommands": [
        {
          "subcommands": [],
          "options": [
            {
              "option": "--progress",
              "shortcut": "-p",
              "description": "Display progress on CLI.",
              "value": "bool",
              "default": "true when STDERR is a TTY"
            }
          ],
          "description": "Fetches a DAG and streams it out as a well-formed .car file.",
          "name": "ipfs dag export",
          "raw_help_text": "USAGE\n  ipfs dag export <root> - Streams the selected DAG as a .car stream on stdout.\n\nSYNOPSIS\n  ipfs dag export [--progress | -p] [--] <root>\n\nARGUMENTS\n\n  <root> - CID of a root to recursively export\n\nOPTIONS\n\n  -p, --progress  bool - Display progress on CLI. Defaults to true when STDERR\n                         is a TTY.\n\nDESCRIPTION\n\n  'ipfs dag export' fetches a DAG and streams it out as a well-formed .car file.\n  Note that at present only single root selections / .car files are supported.\n  The output of blocks happens in strict DAG-traversal, first-seen, order.\n  CAR file follows the CARv1 format: https://ipld.io/specs/transport/car/carv1/"
        },
        {
          "description": "Get a DAG node from IPFS.",
          "subcommands": [],
          "options": [
            {
              "option": "--output-codec",
              "shortcut": null,
              "description": "Format that the object will be encoded as.",
              "value": "string",
              "default": "dag-json"
            }
          ],
          "name": "ipfs dag get",
          "raw_help_text": "USAGE\n  ipfs dag get <ref> - Get a DAG node from IPFS.\n\nSYNOPSIS\n  ipfs dag get [--output-codec=<output-codec>] [--] <ref>\n\nARGUMENTS\n\n  <ref> - The object to get\n\nOPTIONS\n\n  --output-codec  string - Format that the object will be encoded as. Default:\n                           dag-json.\n\nDESCRIPTION\n\n  'ipfs dag get' fetches a DAG node from IPFS and prints it out in the specified\n  format."
        },
        {
          "description": "Import the contents of .car files",
          "subcommands": [],
          "options": [
            {
              "option": "--allow-big-block",
              "shortcut": null,
              "description": "Disable block size check and allow creation of blocks bigger than 1MiB. WARNING: such blocks won't be transferable over the standard bitswap.",
              "value": "bool",
              "default": "false"
            },
            {
              "option": "--fast-provide-root",
              "shortcut": null,
              "description": "Immediately provide root CIDs to DHT in addition to regular queue, for faster discovery.",
              "value": "bool",
              "default": "Import.FastProvideRoot"
            },
            {
              "option": "--fast-provide-wait",
              "shortcut": null,
              "description": "Block until the immediate provide completes before returning.",
              "value": "bool",
              "default": "Import.FastProvideWait"
            },
            {
              "option": "--pin-roots",
              "shortcut": null,
              "description": "Pin optional roots listed in the .car headers after importing.",
              "value": "bool",
              "default": "true"
            },
            {
              "option": "--silent",
              "shortcut": null,
              "description": "No output.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--stats",
              "shortcut": null,
              "description": "Output stats.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs dag import",
          "raw_help_text": "USAGE\n  ipfs dag import <path>... - Import the contents of .car files\n\nSYNOPSIS\n  ipfs dag import [--pin-roots=false] [--silent] [--stats] [--fast-provide-root]\n                  [--fast-provide-wait] [--allow-big-block] [--] <path>...\n\nARGUMENTS\n\n  <path>... - The path of a .car file.\n\nOPTIONS\n\n  --pin-roots          bool - Pin optional roots listed in the .car headers\n                              after importing. Default: true.\n  --silent             bool - No output.\n  --stats              bool - Output stats.\n  --fast-provide-root  bool - Immediately provide root CIDs to DHT in addition\n                              to regular queue, for faster discovery. Default:\n                              Import.FastProvideRoot.\n  --fast-provide-wait  bool - Block until the immediate provide completes\n                              before returning. Default: Import.FastProvideWait.\n  --allow-big-block    bool - Disable block size check and allow creation of\n                              blocks bigger than 1MiB. WARNING: such blocks\n                              won't be transferable over the standard bitswap.\n                              Default: false.\n\nDESCRIPTION\n\n  'ipfs dag import' imports all blocks present in supplied .car\n  ( Content Address aRchive ) files, recursively pinning any roots\n  specified in the CAR file headers, unless --pin-roots is set to false.\n  \n  Note:\n    This command will import all blocks in the CAR file, not just those\n    reachable from the specified roots. However, these other blocks will\n    not be pinned and may be garbage collected later.\n  \n    The pinning of the roots happens after all car files are processed,\n    permitting import of DAGs spanning multiple files.\n  \n    Pinning takes place in offline-mode exclusively, one root at a time.\n    If the combination of blocks from the imported CAR files and what is\n    currently present in the blockstore does not represent a complete DAG,\n    pinning of that individual root will fail.\n  \n  FAST PROVIDE OPTIMIZATION:\n  \n  Root CIDs from CAR headers are immediately provided to the DHT in addition\n  to the regular provide queue, allowing other peers to discover your content\n  right away. This complements the sweep provider, which efficiently provides\n  all blocks according to Provide.Strategy over time.\n  \n  By default, the provide happens in the background without blocking the\n  command. Use --fast-provide-wait to wait for the provide to complete, or\n  --fast-provide-root=false to skip it. Works even with --pin-roots=false.\n  Automatically skipped when DHT is not available.\n  \n  Maximum supported CAR version: 2\n  Specification of CAR formats: https://ipld.io/specs/transport/car/"
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--allow-big-block",
              "shortcut": null,
              "description": "Disable block size check and allow creation of blocks bigger than 1MiB. WARNING: such blocks won't be transferable over the standard bitswap.",
              "value": null,
              "default": "false"
            },
            {
              "option": "--hash",
              "shortcut": null,
              "description": "Hash function to use.",
              "value": null,
              "default": null
            },
            {
              "option": "--input-codec",
              "shortcut": null,
              "description": "Codec that the input object is encoded in.",
              "value": null,
              "default": "dag-json"
            },
            {
              "option": "--pin",
              "shortcut": null,
              "description": "Pin this object when adding.",
              "value": null,
              "default": null
            },
            {
              "option": "--store-codec",
              "shortcut": null,
              "description": "Codec that the stored object will be encoded with.",
              "value": null,
              "default": "dag-cbor"
            }
          ],
          "name": "ipfs dag put",
          "raw_help_text": "USAGE\n  ipfs dag put <object data>... - Add a DAG node to IPFS.\n\nSYNOPSIS\n  ipfs dag put [--store-codec=<store-codec>] [--input-codec=<input-codec>]\n               [--pin] [--hash=<hash>] [--allow-big-block] [--] <object data>...\n\nARGUMENTS\n\n  <object data>... - The object to put\n\nOPTIONS\n\n  --store-codec      string - Codec that the stored object will be encoded\n                              with. Default: dag-cbor.\n  --input-codec      string - Codec that the input object is encoded in.\n                              Default: dag-json.\n  --pin              bool   - Pin this object when adding.\n  --hash             string - Hash function to use.\n  --allow-big-block  bool   - Disable block size check and allow creation of\n                              blocks bigger than 1MiB. WARNING: such blocks\n                              won't be transferable over the standard bitswap.\n                              Default: false.\n\nDESCRIPTION\n\n  'ipfs dag put' accepts input from a file or stdin and parses it\n  into an object of the specified format.",
          "description": "Add a DAG node to IPFS."
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs dag resolve",
          "raw_help_text": "USAGE\n  ipfs dag resolve <ref> - Resolve IPLD block.\n\nSYNOPSIS\n  ipfs dag resolve [--] <ref>\n\nARGUMENTS\n\n  <ref> - The path to resolve\n\nDESCRIPTION\n\n  'ipfs dag resolve' fetches a DAG node from IPFS, prints its address and remaining path.",
          "description": "Resolve IPLD block."
        },
        {
          "command": {
            "description": "'ipfs dag stat' fetches a DAG and returns various statistics about it. Statistics include size and number of blocks.",
            "subcommands": [
              {
                "name": "stat",
                "description": "Get stats for a DAG."
              }
            ],
            "options": [
              {
                "option": "--progress",
                "shortcut": "-p",
                "description": "Return progressive data while reading through the DAG.",
                "value": "bool",
                "default": "true"
              }
            ]
          },
          "name": "ipfs dag stat",
          "raw_help_text": "USAGE\n  ipfs dag stat <root>... - Gets stats for a DAG.\n\nSYNOPSIS\n  ipfs dag stat [--progress=false] [--] <root>...\n\nARGUMENTS\n\n  <root>... - CID of a DAG root to get statistics for\n\nOPTIONS\n\n  -p, --progress  bool - Return progressive data while reading through the DAG.\n                         Default: true.\n\nDESCRIPTION\n\n  'ipfs dag stat' fetches a DAG and returns various statistics about it.\n  Statistics include size and number of blocks.\n  \n  Note: This command skips duplicate blocks in reporting both size and the number of blocks",
          "subcommands": [],
          "description": "Gets stats for a DAG."
        }
      ],
      "options": [],
      "name": "ipfs dag",
      "raw_help_text": "USAGE\n  ipfs dag - Interact with IPLD DAG objects.\n\nSYNOPSIS\n  ipfs dag\n\nDESCRIPTION\n\n  'ipfs dag' is used for creating and manipulating DAG objects/hierarchies.\n  \n  This subcommand is intended to deprecate and replace\n  the existing 'ipfs object' command moving forward.\n\nSUBCOMMANDS\n  ipfs dag export <root>        - Streams the selected DAG as a .car stream on\n                                  stdout.\n  ipfs dag get <ref>            - Get a DAG node from IPFS.\n  ipfs dag import <path>...     - Import the contents of .car files\n  ipfs dag put <object data>... - Add a DAG node to IPFS.\n  ipfs dag resolve <ref>        - Resolve IPLD block.\n  ipfs dag stat <root>...       - Gets stats for a DAG.\n\n  For more information about each command, use:\n  'ipfs dag <subcmd> --help'"
    },
    {
      "subcommands": [
        {
          "subcommands": [
            {
              "subcommands": [],
              "options": [],
              "name": "ipfs diag cmds clear",
              "raw_help_text": "USAGE\n  ipfs diag cmds clear - Clear inactive requests from the log.\n\nSYNOPSIS\n  ipfs diag cmds clear",
              "description": "Clear inactive requests from the log."
            },
            {
              "subcommands": [],
              "options": [],
              "name": "ipfs diag cmds set-time",
              "raw_help_text": "USAGE\n  ipfs diag cmds set-time <time> - Set how long to keep inactive requests in\n                                   the log.\n\nSYNOPSIS\n  ipfs diag cmds set-time [--] <time>\n\nARGUMENTS\n\n  <time> - Time to keep inactive requests in log.",
              "description": "Set how long to keep inactive requests in the log."
            }
          ],
          "options": [
            {
              "option": "--verbose",
              "shortcut": "-v",
              "description": "Print extra information.",
              "value": "bool",
              "default": null
            }
          ],
          "description": "List commands run on this IPFS node.",
          "name": "ipfs diag cmds",
          "raw_help_text": "USAGE\n  ipfs diag cmds - List commands run on this IPFS node.\n\nSYNOPSIS\n  ipfs diag cmds [--verbose | -v]\n\nOPTIONS\n\n  -v, --verbose  bool - Print extra information.\n\nDESCRIPTION\n\n  Lists running and recently run commands.\n\nSUBCOMMANDS\n  ipfs diag cmds clear           - Clear inactive requests from the log.\n  ipfs diag cmds set-time <time> - Set how long to keep inactive requests in\n                                   the log.\n\n  For more information about each command, use:\n  'ipfs diag cmds <subcmd> --help'"
        },
        {
          "description": "Collects profiles from a running go-ipfs daemon into a single zipfile.",
          "subcommands": [],
          "options": [
            {
              "option": "--block-profile-rate",
              "shortcut": null,
              "description": "The duration to wait between sampling goroutine-blocking events for the blocking profile.",
              "value": "<block-profile-rate>",
              "default": "1ms"
            },
            {
              "option": "--collectors",
              "shortcut": null,
              "description": "The list of collectors to use for collecting diagnostic data.",
              "value": "<collectors>",
              "default": "[goroutines-stack goroutines-pprof version heap allocs bin cpu mutex block trace]"
            },
            {
              "option": "--mutex-profile-fraction",
              "shortcut": null,
              "description": "The fraction 1/n of mutex contention events that are reported in the mutex profile.",
              "value": "<mutex-profile-fraction>",
              "default": "4"
            },
            {
              "option": "--output",
              "shortcut": "-o",
              "description": "The path where the output .zip should be stored.",
              "value": "<output>",
              "default": "./ipfs-profile-[timestamp].zip"
            },
            {
              "option": "--profile-time",
              "shortcut": null,
              "description": "The amount of time spent profiling. If this is set to 0, then sampling profiles are skipped.",
              "value": "<profile-time>",
              "default": "30s"
            }
          ],
          "name": "ipfs diag profile",
          "raw_help_text": "USAGE\n  ipfs diag profile - Collect a performance profile for debugging.\n\nSYNOPSIS\n  ipfs diag profile [--output=<output> | -o] [--collectors=<collectors>]...\n                    [--profile-time=<profile-time>]\n                    [--mutex-profile-fraction=<mutex-profile-fraction>]\n                    [--block-profile-rate=<block-profile-rate>]\n\nOPTIONS\n\n  -o, --output              string - The path where the output .zip should be\n                                     stored. Default:\n                                     ./ipfs-profile-[timestamp].zip.\n  --collectors              array  - The list of collectors to use for\n                                     collecting diagnostic data. Default:\n                                     [goroutines-stack goroutines-pprof version\n                                     heap allocs bin cpu mutex block trace].\n  --profile-time            string - The amount of time spent profiling. If\n                                     this is set to 0, then sampling profiles\n                                     are skipped. Default: 30s.\n  --mutex-profile-fraction  int    - The fraction 1/n of mutex contention\n                                     events that are reported in the mutex\n                                     profile. Default: 4.\n  --block-profile-rate      string - The duration to wait between sampling\n                                     goroutine-blocking events for the blocking\n                                     profile. Default: 1ms.\n\nDESCRIPTION\n\n  Collects profiles from a running go-ipfs daemon into a single zipfile.\n  To aid in debugging, this command also attempts to include a copy of\n  the running go-ipfs binary.\n  \n  Profiles can be examined using 'go tool pprof', some tips can be found at\n  https://github.com/ipfs/kubo/blob/master/docs/debug-guide.md.\n  \n  Privacy Notice:\n  \n  The output file includes:\n  \n  - A list of running goroutines.\n  - A CPU profile.\n  - A heap inuse profile.\n  - A heap allocation profile.\n  - A mutex profile.\n  - A block profile.\n  - Your copy of go-ipfs.\n  - The output of 'ipfs version --all'.\n  \n  It does not include:\n  \n  - Any of your IPFS data or metadata.\n  - Your config or private key.\n  - Your IP address.\n  - The contents of your computer's memory, filesystem, etc.\n  \n  However, it could reveal:\n  \n  - Your build path, if you built go-ipfs yourself.\n  - If and how a command/feature is being used (inferred from running functions).\n  - Memory offsets of various data structures.\n  - Any modifications you've made to go-ipfs."
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs diag sys",
          "raw_help_text": "USAGE\n  ipfs diag sys - Print system diagnostic information.\n\nSYNOPSIS\n  ipfs diag sys\n\nDESCRIPTION\n\n  Prints out information about your computer to aid in easier debugging.",
          "description": "Print system diagnostic information."
        }
      ],
      "options": [],
      "name": "ipfs diag",
      "raw_help_text": "USAGE\n  ipfs diag - Generate diagnostic reports.\n\nSYNOPSIS\n  ipfs diag\n\nSUBCOMMANDS\n  ipfs diag cmds    - List commands run on this IPFS node.\n  ipfs diag profile - Collect a performance profile for debugging.\n  ipfs diag sys     - Print system diagnostic information.\n\n  For more information about each command, use:\n  'ipfs diag <subcmd> --help'",
      "description": "Generate diagnostic reports"
    },
    {
      "description": "Interact with unixfs files.",
      "subcommands": [
        {
          "subcommands": [],
          "options": [
            {
              "option": "--cid-version",
              "shortcut": "--cid-ver",
              "description": "Cid version to use. (experimental).",
              "value": "int",
              "default": null
            },
            {
              "option": "--hash",
              "shortcut": null,
              "description": "Hash function to use. Will set Cid version to 1 if used. (experimental).",
              "value": "string",
              "default": null
            }
          ],
          "name": "ipfs files chcid",
          "raw_help_text": "USAGE\n  ipfs files chcid [<path>] - Change the CID version or hash function of the\n                              root node of a given path.\n\nSYNOPSIS\n  ipfs files chcid [--cid-version=<cid-version> | --cid-ver] [--hash=<hash>]\n                   [--] [<path>]\n\nARGUMENTS\n\n  [<path>] - Path to change. Default: '/'.\n\nOPTIONS\n\n  --cid-ver, --cid-version  int    - Cid version to use. (experimental).\n  --hash                    string - Hash function to use. Will set Cid version\n                                     to 1 if used. (experimental).\n\nDESCRIPTION\n\n  Change the CID version or hash function of the root node of a given path.",
          "description": "Change the CID version or hash function of the root node of a given path."
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs files chmod",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs files chmod <mode> <path> - Change optional POSIX mode permissions\n\nSYNOPSIS\n  ipfs files chmod [--] <mode> <path>\n\nARGUMENTS\n\n  <mode> - Mode to apply to node (numeric notation)\n  <path> - Path to apply mode\n\nDESCRIPTION\n\n  The mode argument must be specified in Unix numeric notation.\n  \n      $ ipfs files chmod 0644 /foo\n      $ ipfs files stat /foo\n      ...\n      Type: file\n      Mode: -rw-r--r-- (0644)\n      ...",
          "description": "Change optional POSIX mode permissions."
        },
        {
          "description": "Add references to IPFS files and directories in MFS (or copy within MFS).",
          "subcommands": [],
          "options": [
            {
              "option": "--force",
              "shortcut": null,
              "description": "Force overwrite of existing files.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--parents",
              "shortcut": "-p",
              "description": "Make parent directories as needed.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs files cp",
          "raw_help_text": "USAGE\n  ipfs files cp <source> <dest> - Add references to IPFS files and directories\n                                  in MFS (or copy within MFS).\n\nSYNOPSIS\n  ipfs files cp [--force] [--parents | -p] [--] <source> <dest>\n\nARGUMENTS\n\n  <source> - Source IPFS or MFS path to copy.\n  <dest>   - Destination within MFS.\n\nOPTIONS\n\n  --force        bool - Force overwrite of existing files.\n  -p, --parents  bool - Make parent directories as needed.\n\nDESCRIPTION\n\n  \"ipfs files cp\" can be used to add references to any IPFS file or directory\n  (usually in the form /ipfs/<CID>, but also any resolvable path) into MFS.\n  This performs a lazy copy: the full DAG will not be fetched, only the root\n  node being copied.\n  \n  It can also be used to copy files within MFS, but in the case when an\n  IPFS-path matches an existing MFS path, the IPFS path wins.\n  \n  In order to add content to MFS from disk, you can use \"ipfs add\" to obtain the\n  IPFS Content Identifier and then \"ipfs files cp\" to copy it into MFS:\n  \n  $ ipfs add --quieter --pin=false <your file>\n  # ...\n  # ... outputs the root CID at the end\n  $ ipfs files cp /ipfs/<CID> /your/desired/mfs/path\n  \n  If you wish to fully copy content from a different IPFS peer into MFS, do not\n  forget to force IPFS to fetch the full DAG after doing a \"cp\" operation. i.e:\n  \n  $ ipfs files cp /ipfs/<CID> /your/desired/mfs/path\n  $ ipfs pin add <CID>\n  \n  The lazy-copy feature can also be used to protect partial DAG contents from\n  garbage collection. i.e. adding the Wikipedia root to MFS would not download\n  all the Wikipedia, but will prevent any downloaded Wikipedia-DAG content from\n  being GC'ed."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--",
              "shortcut": null,
              "description": "Indicates the end of command options.",
              "value": null,
              "default": null
            }
          ],
          "name": "ipfs files flush",
          "raw_help_text": "USAGE\n  ipfs files flush [<path>] - Flush a given path's data to disk.\n\nSYNOPSIS\n  ipfs files flush [--] [<path>]\n\nARGUMENTS\n\n  [<path>] - Path to flush. Default: '/'.\n\nDESCRIPTION\n\n  Flush a given path to the disk. This is only useful when other commands\n  are run with the '--flush=false'.",
          "description": "Flush a given path's data to disk."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--long",
              "shortcut": "-l",
              "description": "Use long listing format.",
              "value": "bool",
              "default": null
            },
            {
              "option": "-U",
              "shortcut": null,
              "description": "Do not sort; list entries in directory order.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs files ls",
          "raw_help_text": "USAGE\n  ipfs files ls [<path>] - List directories in the local mutable namespace.\n\nSYNOPSIS\n  ipfs files ls [--long | -l] [-U] [--] [<path>]\n\nARGUMENTS\n\n  [<path>] - Path to show listing for. Defaults to '/'.\n\nOPTIONS\n\n  -l, --long  bool - Use long listing format.\n  -U          bool - Do not sort; list entries in directory order.\n\nDESCRIPTION\n\n  List directories in the local mutable namespace (works on both IPFS and MFS paths).\n  \n  Examples:\n  \n      $ ipfs files ls /welcome/docs/\n      about\n      contact\n      help\n      quick-start\n      readme\n      security-notes\n  \n      $ ipfs files ls /myfiles/a/b/c/d\n      foo\n      bar",
          "description": "List directories in the local mutable namespace."
        },
        {
          "description": "Make directories.",
          "subcommands": [],
          "options": [
            {
              "option": "--cid-version",
              "shortcut": "--cid-ver",
              "description": "Cid version to use. (experimental).",
              "value": "<cid-version>",
              "default": null
            },
            {
              "option": "--hash",
              "shortcut": null,
              "description": "Hash function to use. Will set Cid version to 1 if used. (experimental).",
              "value": "<hash>",
              "default": null
            },
            {
              "option": "--parents",
              "shortcut": "-p",
              "description": "No error if existing, make parent directories as needed.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs files mkdir",
          "raw_help_text": "USAGE\n  ipfs files mkdir <path> - Make directories.\n\nSYNOPSIS\n  ipfs files mkdir [--parents | -p] [--cid-version=<cid-version> | --cid-ver]\n                   [--hash=<hash>] [--] <path>\n\nARGUMENTS\n\n  <path> - Path to dir to make.\n\nOPTIONS\n\n  -p, --parents             bool   - No error if existing, make parent\n                                     directories as needed.\n  --cid-ver, --cid-version  int    - Cid version to use. (experimental).\n  --hash                    string - Hash function to use. Will set Cid version\n                                     to 1 if used. (experimental).\n\nDESCRIPTION\n\n  Create the directory if it does not already exist.\n  \n  The directory will have the same CID version and hash function of the\n  parent directory unless the --cid-version and --hash options are used.\n  \n  NOTE: All paths must be absolute.\n  \n  Examples:\n  \n      $ ipfs files mkdir /test/newdir\n      $ ipfs files mkdir -p /test/does/not/exist/yet"
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs files mv",
          "raw_help_text": "USAGE\n  ipfs files mv <source> <dest> - Move files.\n\nSYNOPSIS\n  ipfs files mv [--] <source> <dest>\n\nARGUMENTS\n\n  <source> - Source file to move.\n  <dest>   - Destination path for file to be moved to.\n\nDESCRIPTION\n\n  Move files around. Just like the traditional Unix mv.\n  \n  Example:\n  \n      $ ipfs files mv /myfs/a/b/c /myfs/foo/newc",
          "description": "Move files."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--offset",
              "shortcut": "-o",
              "description": "Byte offset to begin reading from.",
              "value": "int64",
              "default": null
            },
            {
              "option": "--count",
              "shortcut": "-n",
              "description": "Maximum number of bytes to read.",
              "value": "int64",
              "default": null
            }
          ],
          "name": "ipfs files read",
          "raw_help_text": "USAGE\n  ipfs files read <path> - Read a file from MFS.\n\nSYNOPSIS\n  ipfs files read [--offset=<offset> | -o] [--count=<count> | -n] [--] <path>\n\nARGUMENTS\n\n  <path> - Path to file to be read.\n\nOPTIONS\n\n  -o, --offset  int64 - Byte offset to begin reading from.\n  -n, --count   int64 - Maximum number of bytes to read.\n\nDESCRIPTION\n\n  Read a specified number of bytes from a file at a given offset. By default,\n  it will read the entire file similar to the Unix cat.\n  \n  Examples:\n  \n      $ ipfs files read /test/hello\n      hello",
          "description": "Read a file from MFS."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--force",
              "shortcut": null,
              "description": "Forcibly remove target at path; implies -r for directories.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--recursive",
              "shortcut": "-r",
              "description": "Recursively remove directories.",
              "value": "bool",
              "default": null
            }
          ],
          "description": "Remove a file from MFS.",
          "name": "ipfs files rm",
          "raw_help_text": "USAGE\n  ipfs files rm <path>... - Remove a file from MFS.\n\nSYNOPSIS\n  ipfs files rm [--recursive | -r] [--force] [--] <path>...\n\nARGUMENTS\n\n  <path>... - File to remove.\n\nOPTIONS\n\n  -r, --recursive  bool - Recursively remove directories.\n  --force          bool - Forcibly remove target at path; implies -r for\n                          directories.\n\nDESCRIPTION\n\n  Remove files or directories.\n  \n      $ ipfs files rm /foo\n      $ ipfs files ls /bar\n      cat\n      dog\n      fish\n      $ ipfs files rm -r /bar"
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--format",
              "shortcut": null,
              "description": "Print statistics in given format. Allowed tokens: <hash> <size> <cumulsize> <type> <childs> and optional <mode> <mode-octal> <mtime> <mtime-secs> <mtime-nsecs>. Conflicts with other format options.",
              "value": "<format>",
              "default": "<hash>"
            },
            {
              "option": "--hash",
              "shortcut": null,
              "description": "Print only hash. Implies '--format=<hash>'. Conflicts with other format options.",
              "value": null,
              "default": null
            },
            {
              "option": "--size",
              "shortcut": null,
              "description": "Print only size. Implies '--format=<cumulsize>'. Conflicts with other format options.",
              "value": null,
              "default": null
            },
            {
              "option": "--with-local",
              "shortcut": null,
              "description": "Compute the amount of the dag that is local, and if possible the total size.",
              "value": null,
              "default": null
            }
          ],
          "name": "ipfs files stat",
          "raw_help_text": "USAGE\n  ipfs files stat <path> - Display file status.\n\nSYNOPSIS\n  ipfs files stat [--format=<format>] [--hash] [--size] [--with-local] [--]\n                  <path>\n\nARGUMENTS\n\n  <path> - Path to node to stat.\n\nOPTIONS\n\n  --format      string - Print statistics in given format. Allowed tokens:\n                         <hash> <size> <cumulsize> <type> <childs> and optional\n                         <mode> <mode-octal> <mtime> <mtime-secs>\n                         <mtime-nsecs>.Conflicts with other format options.\n                         Default: <hash>\n  Size: <size>\n  CumulativeSize:\n                         <cumulsize>\n  ChildBlocks: <childs>\n  Type: <type>\n  Mode:\n                         <mode> (<mode-octal>)\n  Mtime: <mtime>.\n  --hash        bool   - Print only hash. Implies '--format=<hash>'. Conflicts\n                         with other format options.\n  --size        bool   - Print only size. Implies '--format=<cumulsize>'.\n                         Conflicts with other format options.\n  --with-local  bool   - Compute the amount of the dag that is local, and if\n                         possible the total size.",
          "description": "Display file status."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--mtime",
              "shortcut": null,
              "description": "Modification time in seconds before or since the Unix Epoch to apply to created UnixFS entries.",
              "value": "int64",
              "default": null
            },
            {
              "option": "--mtime-nsecs",
              "shortcut": null,
              "description": "Modification time fraction in nanoseconds.",
              "value": "uint",
              "default": null
            }
          ],
          "name": "ipfs files touch",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs files touch <path> - Set or change optional POSIX modification times.\n\nSYNOPSIS\n  ipfs files touch [--mtime=<mtime>] [--mtime-nsecs=<mtime-nsecs>] [--] <path>\n\nARGUMENTS\n\n  <path> - Path of target to update.\n\nOPTIONS\n\n  --mtime        int64 - Modification time in seconds before or since the Unix\n                         Epoch to apply to created UnixFS entries.\n  --mtime-nsecs  uint  - Modification time fraction in nanoseconds.\n\nDESCRIPTION\n\n  Examples:\n      # set modification time to now.\n      $ ipfs files touch /foo\n      # set a custom modification time.\n      $ ipfs files touch --mtime=1630937926 /foo",
          "description": "Set or change optional POSIX modification times."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--cid-ver",
              "shortcut": "-e",
              "description": "Cid version to use. (experimental).",
              "value": "int",
              "default": null
            },
            {
              "option": "--create",
              "shortcut": "-e",
              "description": "Create the file if it does not exist.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--hash",
              "shortcut": null,
              "description": "Hash function to use. Will set Cid version to 1 if used. (experimental).",
              "value": "string",
              "default": null
            },
            {
              "option": "--offset",
              "shortcut": "-o",
              "description": "Byte offset to begin writing at.",
              "value": "int64",
              "default": null
            },
            {
              "option": "--parents",
              "shortcut": "-p",
              "description": "Make parent directories as needed.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--raw-leaves",
              "shortcut": null,
              "description": "Use raw blocks for newly created leaf nodes. (experimental).",
              "value": "bool",
              "default": null
            },
            {
              "option": "--truncate",
              "shortcut": "-t",
              "description": "Truncate the file to size zero before writing.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--count",
              "shortcut": "-n",
              "description": "Maximum number of bytes to read.",
              "value": "int64",
              "default": null
            }
          ],
          "name": "ipfs files write",
          "raw_help_text": "USAGE\n  ipfs files write <path> <data> - Append to (modify) a file in MFS.\n\nSYNOPSIS\n  ipfs files write [--offset=<offset> | -o] [--create | -e] [--parents | -p]\n                   [--truncate | -t] [--count=<count> | -n] [--raw-leaves]\n                   [--cid-version=<cid-version> | --cid-ver] [--hash=<hash>]\n                   [--] <path> <data>\n\nARGUMENTS\n\n  <path> - Path to write to.\n  <data> - Data to write.\n\nOPTIONS\n\n  -o, --offset              int64  - Byte offset to begin writing at.\n  -e, --create              bool   - Create the file if it does not exist.\n  -p, --parents             bool   - Make parent directories as needed.\n  -t, --truncate            bool   - Truncate the file to size zero before\n                                     writing.\n  -n, --count               int64  - Maximum number of bytes to read.\n  --raw-leaves              bool   - Use raw blocks for newly created leaf\n                                     nodes. (experimental).\n  --cid-ver, --cid-version  int    - Cid version to use. (experimental).\n  --hash                    string - Hash function to use. Will set Cid version\n                                     to 1 if used. (experimental).\n\nDESCRIPTION\n\n  A low-level MFS command that allows you to append data at the end of a file, or\n  specify a beginning offset within a file to write to. The entire length of the\n  input will be written.\n  \n  If the '--create' option is specified, the file will be created if it does not\n  exist. Nonexistent intermediate directories will not be created unless the\n  '--parents' option is specified.\n  \n  Newly created files will have the same CID version and hash function of the\n  parent directory unless the '--cid-version' and '--hash' options are used.\n  \n  Newly created leaves will be in the legacy format (Protobuf) if the\n  CID version is 0, or raw if the CID version is non-zero.  Use of the\n  '--raw-leaves' option will override this behavior.\n  \n  If the '--flush' option is set to false, changes will not be propagated to the\n  merkledag root. This can make operations much faster when doing a large number\n  of writes to a deeper directory structure.\n  \n  EXAMPLE:\n  \n      echo \"hello world\" | ipfs files write --create --parents /myfs/a/b/file\n      echo \"hello world\" | ipfs files write --truncate /myfs/a/b/file\n  \n  WARNING:\n  \n  Usage of the '--flush=false' option does not guarantee data durability until\n  the tree has been flushed. This can be accomplished by running 'ipfs files\n  stat' on the file or any of its ancestors.\n  \n  WARNING:\n  \n  The CID produced by 'files write' will be different from 'ipfs add' because\n  'ipfs file write' creates a trickle-dag optimized for append-only operations\n  See '--trickle' in 'ipfs add --help' for more information.\n  \n  If you want to add a file without modifying an existing one,\n  use 'ipfs add' with '--to-files':\n  \n    > ipfs files mkdir -p /myfs/dir\n    > ipfs add example.jpg --to-files /myfs/dir/\n    > ipfs files ls /myfs/dir/\n    example.jpg\n  \n  See '--to-files' in 'ipfs add --help' for more information.",
          "description": "Append to (modify) a file in MFS."
        }
      ],
      "options": [
        {
          "option": "--flush",
          "shortcut": "-f",
          "description": "Flush target and ancestors after write.",
          "value": "false",
          "default": "true"
        }
      ],
      "name": "ipfs files",
      "raw_help_text": "USAGE\n  ipfs files - Interact with unixfs files.\n\nSYNOPSIS\n  ipfs files [--flush=false]\n\nOPTIONS\n\n  -f, --flush  bool - Flush target and ancestors after write. Default: true.\n\nDESCRIPTION\n\n  Files is an API for manipulating IPFS objects as if they were a Unix\n  filesystem.\n  \n  The files facility interacts with MFS (Mutable File System). MFS acts as a\n  single, dynamic filesystem mount. MFS has a root CID that is transparently\n  updated when a change happens (and can be checked with \"ipfs files stat /\").\n  \n  All files and folders within MFS are respected and will not be deleted\n  during garbage collections. However, a DAG may be referenced in MFS without\n  being fully available locally (MFS content is lazy loaded when accessed).\n  MFS is independent from the list of pinned items (\"ipfs pin ls\"). Calls to\n  \"ipfs pin add\" and \"ipfs pin rm\" will add and remove pins independently of\n  MFS. If MFS content that was additionally pinned is removed by calling\n  \"ipfs files rm\", it will still remain pinned.\n  \n  Content added with \"ipfs add\" (which by default also becomes pinned), is not\n  added to MFS. Any content can be lazily referenced from MFS with the command\n  \"ipfs files cp /ipfs/<cid> /some/path/\" (see ipfs files cp --help).\n  \n  NOTE: Most of the subcommands of 'ipfs files' accept the '--flush' flag. It\n  defaults to true and ensures two things: 1) that the changes are reflected in\n  the full MFS structure (updated CIDs) 2) that the parent-folder's cache is\n  cleared. Use caution when setting this flag to false. It will improve\n  performance for large numbers of file operations, but it does so at the cost\n  of consistency guarantees. If the daemon is unexpectedly killed before running\n  'ipfs files flush' on the files in question, then data may be lost. This also\n  applies to run 'ipfs repo gc' concurrently with '--flush=false' operations.\n  \n  When using '--flush=false', operations are limited to prevent unbounded\n  memory growth. After reaching Internal.MFSNoFlushLimit operations, further\n  operations will fail until you run 'ipfs files flush'. This explicit failure\n  (instead of auto-flushing) ensures you maintain control over when data is\n  persisted, preventing unexpected partial states and making batch operations\n  predictable. We recommend flushing paths regularly, especially folders with\n  many write operations, to clear caches, free memory, and maintain good\n  performance.\n\nSUBCOMMANDS\n  ipfs files chcid [<path>]      - Change the CID version or hash function of\n                                   the root node of a given path.\n  ipfs files cp <source> <dest>  - Add references to IPFS files and directories\n                                   in MFS (or copy within MFS).\n  ipfs files flush [<path>]      - Flush a given path's data to disk.\n  ipfs files ls [<path>]         - List directories in the local mutable\n                                   namespace.\n  ipfs files mkdir <path>        - Make directories.\n  ipfs files mv <source> <dest>  - Move files.\n  ipfs files read <path>         - Read a file from MFS.\n  ipfs files rm <path>...        - Remove a file from MFS.\n  ipfs files stat <path>         - Display file status.\n  ipfs files write <path> <data> - Append to (modify) a file in MFS.\n\n  For more information about each command, use:\n  'ipfs files <subcmd> --help'\n\nEXPERIMENTAL SUBCOMMANDS\n  ipfs files chmod <mode> <path> - Change optional POSIX mode permissions\n  ipfs files touch <path>        - Set or change optional POSIX modification\n                                   times."
    },
    {
      "description": "Interact with filestore objects.",
      "subcommands": [
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs filestore dups",
          "raw_help_text": "USAGE\n  ipfs filestore dups - List blocks that are both in the filestore and standard\n                        block storage.\n\nSYNOPSIS\n  ipfs filestore dups",
          "description": "List blocks that are both in the filestore and standard block storage."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--file-order",
              "shortcut": null,
              "description": "sort the results based on the path of the backing file.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs filestore ls",
          "raw_help_text": "USAGE\n  ipfs filestore ls [<obj>]... - List objects in filestore.\n\nSYNOPSIS\n  ipfs filestore ls [--file-order] [--] [<obj>...]\n\nARGUMENTS\n\n  [<obj>]... - Cid of objects to list.\n\nOPTIONS\n\n  --file-order  bool - sort the results based on the path of the backing file.\n\nDESCRIPTION\n\n  List objects in the filestore.\n  \n  If one or more <obj> is specified only list those specific objects,\n  otherwise list all objects.\n  \n  The output is:\n  \n  <hash> <size> <path> <offset>",
          "description": "List objects in filestore."
        },
        {
          "description": "Verify objects in the filestore.",
          "subcommands": [],
          "options": [
            {
              "option": "--file-order",
              "shortcut": null,
              "description": "verify the objects based on the order of the backing file.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--remove-bad-blocks",
              "shortcut": null,
              "description": "remove bad blocks. WARNING: This may remove pinned data. You should run 'ipfs pin verify' after running this command and correct any issues.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs filestore verify",
          "raw_help_text": "USAGE\n  ipfs filestore verify [<obj>]... - Verify objects in filestore.\n\nSYNOPSIS\n  ipfs filestore verify [--file-order] [--remove-bad-blocks] [--] [<obj>...]\n\nARGUMENTS\n\n  [<obj>]... - Cid of objects to verify.\n\nOPTIONS\n\n  --file-order         bool - verify the objects based on the order of the\n                              backing file.\n  --remove-bad-blocks  bool - remove bad blocks. WARNING: This may remove\n                              pinned data. You should run 'ipfs pin verify'\n                              after running this command and correct any issues.\n\nDESCRIPTION\n\n  Verify objects in the filestore.\n  \n  If one or more <obj> is specified only verify those specific objects,\n  otherwise verify all objects.\n  \n  The output is:\n  \n  <status> <hash> <size> <path> <offset> [<action>]\n  \n  Where <status> is one of:\n  ok:       the block can be reconstructed\n  changed:  the contents of the backing file have changed\n  no-file:  the backing file could not be found\n  error:    there was some other problem reading the file\n  missing:  <obj> could not be found in the filestore\n  ERROR:    internal error, most likely due to a corrupt database\n  \n  Where <action> is present only when removing bad blocks and is one of:\n  remove:   link to the block will be removed from datastore\n  keep:     keep link, nothing to do\n  \n  For ERROR entries the error will also be printed to stderr."
        }
      ],
      "options": [],
      "name": "ipfs filestore",
      "raw_help_text": "USAGE\n  ipfs filestore - Interact with filestore objects.\n\nSYNOPSIS\n  ipfs filestore\n\nSUBCOMMANDS\n  ipfs filestore dups              - List blocks that are both in the filestore\n                                     and standard block storage.\n  ipfs filestore ls [<obj>]...     - List objects in filestore.\n  ipfs filestore verify [<obj>]... - Verify objects in filestore.\n\n  For more information about each command, use:\n  'ipfs filestore <subcmd> --help'"
    },
    {
      "description": "Download IPFS objects.",
      "subcommands": [],
      "options": [
        {
          "option": "--archive",
          "shortcut": "-a",
          "description": "Output a TAR archive.",
          "value": "bool",
          "default": null
        },
        {
          "option": "--compress",
          "shortcut": "-C",
          "description": "Compress the output with GZIP compression.",
          "value": "bool",
          "default": null
        },
        {
          "option": "--compression-level",
          "shortcut": "-l",
          "description": "The level of compression (1-9).",
          "value": "int",
          "default": null
        },
        {
          "option": "--output",
          "shortcut": "-o",
          "description": "The path where the output should be stored.",
          "value": "string",
          "default": null
        },
        {
          "option": "--progress",
          "shortcut": "-p",
          "description": "Stream progress data.",
          "value": "bool",
          "default": "true"
        }
      ],
      "name": "ipfs get",
      "raw_help_text": "USAGE\n  ipfs get <ipfs-path> - Download IPFS objects.\n\nSYNOPSIS\n  ipfs get [--output=<output> | -o] [--archive | -a] [--compress | -C]\n           [--compression-level=<compression-level> | -l] [--progress=false]\n           [--] <ipfs-path>\n\nARGUMENTS\n\n  <ipfs-path> - The path to the IPFS object(s) to be outputted.\n\nOPTIONS\n\n  -o, --output             string - The path where the output should be stored.\n  -a, --archive            bool   - Output a TAR archive.\n  -C, --compress           bool   - Compress the output with GZIP compression.\n  -l, --compression-level  int    - The level of compression (1-9).\n  -p, --progress           bool   - Stream progress data. Default: true.\n\nDESCRIPTION\n\n  Stores to disk the data contained an IPFS or IPNS object(s) at the given path.\n  \n  By default, the output will be stored at './<ipfs-path>', but an alternate\n  path can be specified with '--output=<path>' or '-o=<path>'.\n  \n  To output a TAR archive instead of unpacked files, use '--archive' or '-a'.\n  \n  To compress the output with GZIP compression, use '--compress' or '-C'. You\n  may also specify the level of compression by specifying '-l=<1-9>'."
    },
    {
      "subcommands": [],
      "options": [
        {
          "option": "--format",
          "shortcut": "-f",
          "description": "Optional output format.",
          "value": "string",
          "default": null
        },
        {
          "option": "--peerid-base",
          "shortcut": null,
          "description": "Encoding used for peer IDs: Can either be a multibase encoded CID or a base58btc encoded multihash. Takes {b58mh|base36|k|base32|b...}.",
          "value": "string",
          "default": "b58mh"
        }
      ],
      "name": "ipfs id",
      "raw_help_text": "USAGE\n  ipfs id [<peerid>] - Show IPFS node id info.\n\nSYNOPSIS\n  ipfs id [--format=<format> | -f] [--peerid-base=<peerid-base>] [--] [<peerid>]\n\nARGUMENTS\n\n  [<peerid>] - Peer.ID of node to look up.\n\nOPTIONS\n\n  -f, --format   string - Optional output format.\n  --peerid-base  string - Encoding used for peer IDs: Can either be a multibase\n                          encoded CID or a base58btc encoded multihash. Takes\n                          {b58mh|base36|k|base32|b...}. Default: b58mh.\n\nDESCRIPTION\n\n  Prints out information about the specified peer.\n  If no peer is specified, prints out information for local peers.\n  \n  'ipfs id' supports the format option for output with the following keys:\n  <id> : The peers id.\n  <aver>: Agent version.\n  <pver>: Protocol version.\n  <pubkey>: Public key.\n  <addrs>: Addresses (newline delimited).\n  <protocols>: Libp2p Protocol registrations (newline delimited).\n  \n  EXAMPLE:\n  \n      ipfs id Qmece2RkXhsKe5CRooNisBTh4SK119KrXXGmoK6V3kb8aH -f=\"<addrs>\\n\"",
      "description": "Show info about IPFS peers"
    },
    {
      "subcommands": [],
      "options": [
        {
          "option": "--algorithm",
          "shortcut": "-a",
          "description": "Cryptographic algorithm to use for key generation.",
          "value": "string",
          "default": "ed25519"
        },
        {
          "option": "--bits",
          "shortcut": "-b",
          "description": "Number of bits to use in the generated RSA private key.",
          "value": "int",
          "default": null
        },
        {
          "option": "--empty-repo",
          "shortcut": "-e",
          "description": "Don't add and pin help files to the local storage.",
          "value": "bool",
          "default": "true"
        },
        {
          "option": "--profile",
          "shortcut": "-p",
          "description": "Apply profile settings to config. Multiple profiles can be separated by ','.",
          "value": "string",
          "default": null
        }
      ],
      "name": "ipfs init",
      "raw_help_text": "USAGE\n  ipfs init [<default-config>] - Initializes ipfs config file.\n\nSYNOPSIS\n  ipfs init [--algorithm=<algorithm> | -a] [--bits=<bits> | -b]\n            [--empty-repo=false] [--profile=<profile> | -p] [--]\n            [<default-config>]\n\nARGUMENTS\n\n  [<default-config>] - Initialize with the given configuration.\n\nOPTIONS\n\n  -a, --algorithm   string - Cryptographic algorithm to use for key generation.\n                             Default: ed25519.\n  -b, --bits        int    - Number of bits to use in the generated RSA private\n                             key.\n  -e, --empty-repo  bool   - Don't add and pin help files to the local storage.\n                             Default: true.\n  -p, --profile     string - Apply profile settings to config. Multiple\n                             profiles can be separated by ','.\n\nDESCRIPTION\n\n  Initializes ipfs configuration files and generates a new keypair.\n  \n  If you are going to run IPFS in server environment, you may want to\n  initialize it using 'server' profile.\n  \n  For the list of available profiles see 'ipfs config profile --help'\n  \n  ipfs uses a repository in the local file system. By default, the repo is\n  located at ~/.ipfs. To change the repo location, set the $IPFS_PATH\n  environment variable:\n  \n      export IPFS_PATH=/path/to/ipfsrepo",
      "description": "Initialize local IPFS configuration"
    },
    {
      "subcommands": [
        {
          "subcommands": [],
          "options": [
            {
              "option": "--format",
              "shortcut": "-f",
              "description": "The format of the exported private key, libp2p-protobuf-cleartext or pem-pkcs8-cleartext.",
              "value": "<format>",
              "default": "libp2p-protobuf-cleartext"
            },
            {
              "option": "--output",
              "shortcut": "-o",
              "description": "The path where the output should be stored.",
              "value": "<output>",
              "default": null
            }
          ],
          "name": "ipfs key export",
          "raw_help_text": "USAGE\n  ipfs key export <name> - Export a keypair\n\nSYNOPSIS\n  ipfs key export [--output=<output> | -o] [--format=<format> | -f] [--] <name>\n\nARGUMENTS\n\n  <name> - name of key to export\n\nOPTIONS\n\n  -o, --output  string - The path where the output should be stored.\n  -f, --format  string - The format of the exported private key,\n                         libp2p-protobuf-cleartext or pem-pkcs8-cleartext.\n                         Default: libp2p-protobuf-cleartext.\n\nDESCRIPTION\n\n  Exports a named libp2p key to disk.\n  \n  By default, the output will be stored at './<key-name>.key', but an alternate\n  path can be specified with '--output=<path>' or '-o=<path>'.\n  \n  It is possible to export a private key to interoperable PEM PKCS8 format by explicitly\n  passing '--format=pem-pkcs8-cleartext'. The resulting PEM file can then be consumed\n  elsewhere. For example, using openssl to get a PEM with public key:\n  \n    $ ipfs key export testkey --format=pem-pkcs8-cleartext -o privkey.pem\n    $ openssl pkey -in privkey.pem -pubout > pubkey.pem",
          "description": "Export a keypair"
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--ipns-base",
              "shortcut": null,
              "description": "Encoding used for keys: Can either be a multibase encoded CID or a base58btc encoded multihash. Takes {b58mh|base36|k|base32|b...}.",
              "value": "<ipns-base>",
              "default": "base36"
            },
            {
              "option": "--size",
              "shortcut": "-s",
              "description": "size of the key to generate.",
              "value": "<size>",
              "default": null
            },
            {
              "option": "--type",
              "shortcut": "-t",
              "description": "type of the key to create: rsa, ed25519.",
              "value": "<type>",
              "default": "ed25519"
            }
          ],
          "name": "ipfs key gen",
          "raw_help_text": "USAGE\n  ipfs key gen <name> - Create a new keypair\n\nSYNOPSIS\n  ipfs key gen [--type=<type> | -t] [--size=<size> | -s]\n               [--ipns-base=<ipns-base>] [--] <name>\n\nARGUMENTS\n\n  <name> - name of key to create\n\nOPTIONS\n\n  -t, --type   string - type of the key to create: rsa, ed25519. Default:\n                        ed25519.\n  -s, --size   int    - size of the key to generate.\n  --ipns-base  string - Encoding used for keys: Can either be a multibase\n                        encoded CID or a base58btc encoded multihash. Takes\n                        {b58mh|base36|k|base32|b...}. Default: base36.",
          "description": "Create a new keypair"
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--allow-any-key-type",
              "shortcut": null,
              "description": "Allow importing any key type.",
              "value": "bool",
              "default": "false"
            },
            {
              "option": "--format",
              "shortcut": "-f",
              "description": "The format of the private key to import, libp2p-protobuf-cleartext or pem-pkcs8-cleartext.",
              "value": "string",
              "default": "libp2p-protobuf-cleartext"
            },
            {
              "option": "--ipns-base",
              "shortcut": null,
              "description": "Encoding used for keys: Can either be a multibase encoded CID or a base58btc encoded multihash. Takes {b58mh|base36|k|base32|b...}.",
              "value": "string",
              "default": "base36"
            }
          ],
          "name": "ipfs key import",
          "raw_help_text": "USAGE\n  ipfs key import <name> <key> - Import a key and prints imported key id\n\nSYNOPSIS\n  ipfs key import [--ipns-base=<ipns-base>] [--format=<format> | -f]\n                  [--allow-any-key-type] [--] <name> <key>\n\nARGUMENTS\n\n  <name> - name to associate with key in keychain\n  <key>  - key provided by generate or export\n\nOPTIONS\n\n  --ipns-base           string - Encoding used for keys: Can either be a\n                                 multibase encoded CID or a base58btc encoded\n                                 multihash. Takes {b58mh|base36|k|base32|b...}.\n                                 Default: base36.\n  -f, --format          string - The format of the private key to import,\n                                 libp2p-protobuf-cleartext or\n                                 pem-pkcs8-cleartext. Default:\n                                 libp2p-protobuf-cleartext.\n  --allow-any-key-type  bool   - Allow importing any key type. Default: false.\n\nDESCRIPTION\n\n  Imports a key and stores it under the provided name.\n  \n  By default, the key is assumed to be in 'libp2p-protobuf-cleartext' format,\n  however it is possible to import private keys wrapped in interoperable PEM PKCS8\n  by passing '--format=pem-pkcs8-cleartext'.\n  \n  The PEM format allows for key generation outside of the IPFS node:\n  \n    $ openssl genpkey -algorithm ED25519 > ed25519.pem\n    $ ipfs key import test-openssl -f pem-pkcs8-cleartext ed25519.pem",
          "description": "Import a key and prints imported key id"
        },
        {
          "description": "Manage IPFS keys.",
          "subcommands": [],
          "options": [
            {
              "option": "--ipns-base",
              "shortcut": "-l",
              "description": "Encoding used for keys: Can either be a multibase encoded CID or a base58btc encoded multihash. Takes {b58mh|base36|k|base32|b...}.",
              "value": "<ipns-base>",
              "default": "base36"
            },
            {
              "option": "-l",
              "shortcut": null,
              "description": "Show extra information about keys.",
              "value": null,
              "default": null
            }
          ],
          "name": "ipfs key list",
          "raw_help_text": "USAGE\n  ipfs key list - List all local keypairs.\n\nSYNOPSIS\n  ipfs key list [-l] [--ipns-base=<ipns-base>]\n\nOPTIONS\n\n  -l           bool   - Show extra information about keys.\n  --ipns-base  string - Encoding used for keys: Can either be a multibase\n                        encoded CID or a base58btc encoded multihash. Takes\n                        {b58mh|base36|k|base32|b...}. Default: base36."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--force",
              "shortcut": "-f",
              "description": "Allow to overwrite an existing key.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--ipns-base",
              "shortcut": null,
              "description": "Encoding used for keys: Can either be a multibase encoded CID or a base58btc encoded multihash. Takes {b58mh|base36|k|base32|b...}.",
              "value": "string",
              "default": "base36"
            }
          ],
          "name": "ipfs key rename",
          "raw_help_text": "USAGE\n  ipfs key rename <name> <newName> - Rename a keypair.\n\nSYNOPSIS\n  ipfs key rename [--force | -f] [--ipns-base=<ipns-base>] [--] <name> <newName>\n\nARGUMENTS\n\n  <name>    - name of key to rename\n  <newName> - new name of the key\n\nOPTIONS\n\n  -f, --force  bool   - Allow to overwrite an existing key.\n  --ipns-base  string - Encoding used for keys: Can either be a multibase\n                        encoded CID or a base58btc encoded multihash. Takes\n                        {b58mh|base36|k|base32|b...}. Default: base36.",
          "description": "Rename a keypair."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--ipns-base",
              "shortcut": null,
              "description": "Encoding used for keys: Can either be a multibase encoded CID or a base58btc encoded multihash. Takes {b58mh|base36|k|base32|b...}.",
              "value": "<ipns-base>",
              "default": "base36"
            },
            {
              "option": "-l",
              "shortcut": null,
              "description": "Show extra information about keys.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs key rm",
          "raw_help_text": "USAGE\n  ipfs key rm <name>... - Remove a keypair.\n\nSYNOPSIS\n  ipfs key rm [-l] [--ipns-base=<ipns-base>] [--] <name>...\n\nARGUMENTS\n\n  <name>... - names of keys to remove\n\nOPTIONS\n\n  -l           bool   - Show extra information about keys.\n  --ipns-base  string - Encoding used for keys: Can either be a multibase\n                        encoded CID or a base58btc encoded multihash. Takes\n                        {b58mh|base36|k|base32|b...}. Default: base36.",
          "description": "Remove a keypair."
        },
        {
          "name": "ipfs key rotate",
          "description": "Rotates the IPFS identity.",
          "subcommands": [],
          "options": [
            {
              "option": "--oldkey",
              "shortcut": "-o",
              "description": "Keystore name to use for backing up your existing identity.",
              "value": "string",
              "default": null
            },
            {
              "option": "--type",
              "shortcut": "-t",
              "description": "type of the key to create: rsa, ed25519. Default: ed25519.",
              "value": "string",
              "default": "ed25519"
            },
            {
              "option": "--size",
              "shortcut": "-s",
              "description": "size of the key to generate.",
              "value": "int",
              "default": null
            }
          ],
          "raw_help_text": "USAGE\n  ipfs key rotate - Rotates the IPFS identity.\n\nSYNOPSIS\n  ipfs key rotate [--oldkey=<oldkey> | -o] [--type=<type> | -t]\n                  [--size=<size> | -s]\n\nOPTIONS\n\n  -o, --oldkey  string - Keystore name to use for backing up your existing\n                         identity.\n  -t, --type    string - type of the key to create: rsa, ed25519. Default:\n                         ed25519.\n  -s, --size    int    - size of the key to generate.\n\nDESCRIPTION\n\n  Generates a new ipfs identity and saves it to the ipfs config file.\n  Your existing identity key will be backed up in the Keystore.\n  The daemon must not be running when calling this command.\n  \n  ipfs uses a repository in the local file system. By default, the repo is\n  located at ~/.ipfs. To change the repo location, set the $IPFS_PATH\n  environment variable:\n  \n      export IPFS_PATH=/path/to/ipfsrepo"
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--ipns-base",
              "shortcut": null,
              "description": "Encoding used for keys: Can either be a multibase encoded CID or a base58btc encoded multihash. Takes {b58mh|base36|k|base32|b...}.",
              "value": "<ipns-base>",
              "default": "base36"
            },
            {
              "option": "--key",
              "shortcut": "-k",
              "description": "The name of the key to use for signing.",
              "value": "<key>",
              "default": null
            }
          ],
          "name": "ipfs key sign",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs key sign <data> - Generates a signature for the given data with a\n                         specified key. Useful for proving the key ownership.\n\nSYNOPSIS\n  ipfs key sign [--key=<key> | -k] [--ipns-base=<ipns-base>] [--] <data>\n\nARGUMENTS\n\n  <data> - The data to sign.\n\nOPTIONS\n\n  -k, --key    string - The name of the key to use for signing.\n  --ipns-base  string - Encoding used for keys: Can either be a multibase\n                        encoded CID or a base58btc encoded multihash. Takes\n                        {b58mh|base36|k|base32|b...}. Default: base36.\n\nDESCRIPTION\n\n  Sign arbitrary bytes, such as to prove ownership of a Peer ID or an IPNS Name.\n  To avoid signature reuse, the signed payload is always prefixed with\n  \"libp2p-key signed message:\".",
          "description": "Generates a signature for the given data with a specified key."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--ipns-base",
              "shortcut": null,
              "description": "Encoding used for keys: Can either be a multibase encoded CID or a base58btc encoded multihash. Takes {b58mh|base36|k|base32|b...}.",
              "value": "<ipns-base>",
              "default": "base36"
            },
            {
              "option": "--key",
              "shortcut": "-k",
              "description": "The name of the key to use for signing.",
              "value": "<key>",
              "default": null
            },
            {
              "option": "--signature",
              "shortcut": "-s",
              "description": "Multibase-encoded signature to verify.",
              "value": "<signature>",
              "default": null
            }
          ],
          "name": "ipfs key verify",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs key verify <data> - Verify that the given data and signature match.\n\nSYNOPSIS\n  ipfs key verify [--key=<key> | -k] [--signature=<signature> | -s]\n                  [--ipns-base=<ipns-base>] [--] <data>\n\nARGUMENTS\n\n  <data> - The data to verify against the given signature.\n\nOPTIONS\n\n  -k, --key        string - The name of the key to use for signing.\n  -s, --signature  string - Multibase-encoded signature to verify.\n  --ipns-base      string - Encoding used for keys: Can either be a multibase\n                            encoded CID or a base58btc encoded multihash. Takes\n                            {b58mh|base36|k|base32|b...}. Default: base36.\n\nDESCRIPTION\n\n  Verify if the given data and signatures match. To avoid the signature reuse,\n  the signed payload is always prefixed with \"libp2p-key signed message:\".",
          "description": "Verify that the given data and signature match."
        }
      ],
      "options": [],
      "name": "ipfs key",
      "raw_help_text": "USAGE\n  ipfs key - Create and list IPNS name keypairs\n\nSYNOPSIS\n  ipfs key\n\nDESCRIPTION\n\n  'ipfs key gen' generates a new keypair for usage with IPNS and 'ipfs name\n  publish'.\n  \n    > ipfs key gen --type=rsa --size=2048 mykey\n    > ipfs name publish --key=mykey QmSomeHash\n  \n  'ipfs key list' lists the available keys.\n  \n    > ipfs key list\n    self\n    mykey\n  \t\t\n\nSUBCOMMANDS\n  ipfs key export <name>           - Export a keypair\n  ipfs key gen <name>              - Create a new keypair\n  ipfs key import <name> <key>     - Import a key and prints imported key id\n  ipfs key list                    - List all local keypairs.\n  ipfs key rename <name> <newName> - Rename a keypair.\n  ipfs key rm <name>...            - Remove a keypair.\n  ipfs key rotate                  - Rotates the IPFS identity.\n\n  For more information about each command, use:\n  'ipfs key <subcmd> --help'\n\nEXPERIMENTAL SUBCOMMANDS\n  ipfs key sign <data>   - Generates a signature for the given data with a\n                           specified key. Useful for proving the key ownership.\n  ipfs key verify <data> - Verify that the given data and signature match.",
      "description": "Create and list IPNS name keypairs"
    },
    {
      "description": "List directory contents for Unix filesystem objects.",
      "subcommands": [],
      "options": [
        {
          "option": "--headers",
          "shortcut": "-v",
          "description": "Print table headers (Hash, Size, Name).",
          "value": "bool",
          "default": null
        },
        {
          "option": "--resolve-type",
          "shortcut": null,
          "description": "Resolve linked objects to find out their types.",
          "value": "bool",
          "default": "true"
        },
        {
          "option": "--size",
          "shortcut": null,
          "description": "Resolve linked objects to find out their file size.",
          "value": "bool",
          "default": "true"
        },
        {
          "option": "--stream",
          "shortcut": "-s",
          "description": "Enable experimental streaming of directory entries as they are traversed.",
          "value": "bool",
          "default": null
        }
      ],
      "name": "ipfs ls",
      "raw_help_text": "USAGE\n  ipfs ls <ipfs-path>... - List directory contents for Unix filesystem objects.\n\nSYNOPSIS\n  ipfs ls [--headers | -v] [--resolve-type=false] [--size=false] [--stream | -s]\n          [--] <ipfs-path>...\n\nARGUMENTS\n\n  <ipfs-path>... - The path to the IPFS object(s) to list links from.\n\nOPTIONS\n\n  -v, --headers   bool - Print table headers (Hash, Size, Name).\n  --resolve-type  bool - Resolve linked objects to find out their types.\n                         Default: true.\n  --size          bool - Resolve linked objects to find out their file size.\n                         Default: true.\n  -s, --stream    bool - Enable experimental streaming of directory entries as\n                         they are traversed.\n\nDESCRIPTION\n\n  Displays the contents of an IPFS or IPNS object(s) at the given path, with\n  the following format:\n  \n    <link base58 hash> <link size in bytes> <link name>\n  \n  The JSON output contains type information."
    },
    {
      "description": "Interact with the daemon log output.",
      "subcommands": [
        {
          "description": "Change or get the logging level.",
          "subcommands": [],
          "options": [
            {
              "option": "--",
              "shortcut": null,
              "description": "Indicates the start of options.",
              "value": null,
              "default": null
            }
          ],
          "name": "ipfs log level",
          "raw_help_text": "USAGE\n  ipfs log level [<subsystem>] [<level>] - Change or get the logging level.\n\nSYNOPSIS\n  ipfs log level [--] [<subsystem>] [<level>]\n\nARGUMENTS\n\n  [<subsystem>] - The subsystem logging identifier. Use 'all' or '*' to get or\n                  set the log level of all subsystems including the default. If\n                  not specified, only show the default log level.\n  [<level>]     - The log level, with 'debug' as the most verbose and 'fatal'\n                  the least verbose. Use 'default' to set to the current\n                  default level. One of: debug, info, warn, error, dpanic,\n                  panic, fatal, default\n\nDESCRIPTION\n\n  Get or change the logging level of one or all logging subsystems.\n  \n  This command provides a runtime alternative to the GOLOG_LOG_LEVEL\n  environment variable for debugging and troubleshooting.\n  \n  UNDERSTANDING DEFAULT vs '*':\n  \n  The \"default\" level is the fallback used by unconfigured subsystems.\n  You cannot set the default level directly - it only changes when you use '*'.\n  \n  The '*' wildcard represents ALL subsystems including the default level.\n  Setting '*' changes everything at once, including the default.\n  \n  EXAMPLES - Getting levels:\n  \n    ipfs log level              # Show only the default fallback level\n    ipfs log level all          # Show all subsystem levels (100+ lines)\n    ipfs log level core         # Show level for 'core' subsystem only\n  \n  EXAMPLES - Setting levels:\n  \n    ipfs log level core debug   # Set 'core' to 'debug' (default unchanged)\n    ipfs log level all info     # Set ALL to 'info' (including default)\n    ipfs log level core default # Reset 'core' to use current default level\n  \n  WILDCARD OPTIONS:\n  \n  Use 'all' (convenient) or '*' (requires escaping) to affect all subsystems:\n    ipfs log level all debug    # Convenient - no shell escaping needed\n    ipfs log level '*' debug    # Equivalent but needs quotes: '*' or \"*\" or \\*\n  \n  BEHAVIOR EXAMPLES:\n  \n  Initial state (all using default 'error'):\n    $ ipfs log level              => error\n    $ ipfs log level core         => error\n  \n  After setting one subsystem:\n    $ ipfs log level core debug\n    $ ipfs log level              => error (default unchanged!)\n    $ ipfs log level core         => debug (explicitly set)\n    $ ipfs log level dht          => error (still uses default)\n  \n  After setting everything with 'all':\n    $ ipfs log level all info\n    $ ipfs log level              => info (default changed!)\n    $ ipfs log level core         => info (all changed)\n    $ ipfs log level dht          => info (all changed)\n  \n  The 'default' keyword always refers to the current default level:\n    $ ipfs log level              => error\n    $ ipfs log level core default  # Sets core to 'error'\n    $ ipfs log level all info      # Changes default to 'info'\n    $ ipfs log level core default  # Now sets core to 'info'"
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs log ls",
          "raw_help_text": "USAGE\n  ipfs log ls - List the logging subsystems.\n\nSYNOPSIS\n  ipfs log ls\n\nDESCRIPTION\n\n  'ipfs log ls' is a utility command used to list the logging\n  subsystems of a running daemon.",
          "description": "List the logging subsystems."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--log-level",
              "shortcut": null,
              "description": "Log level to listen to.",
              "value": "string",
              "default": "."
            }
          ],
          "name": "ipfs log tail",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs log tail - Read and output log messages.\n\nSYNOPSIS\n  ipfs log tail [--log-level=<log-level>]\n\nOPTIONS\n\n  --log-level  string - Log level to listen to. Default: .\n\nDESCRIPTION\n\n  Outputs log messages as they are generated.\n  \n  NOTE: --log-level requires the server to be logging at least at this level\n  \n  Example:\n  \n    GOLOG_LOG_LEVEL=\"error,bitswap=debug\" ipfs daemon\n    ipfs log tail --log-level info\n  \n  This will only return 'info' logs from bitswap and skip 'debug'.",
          "description": "Read and output log messages."
        }
      ],
      "options": [],
      "name": "ipfs log",
      "raw_help_text": "USAGE\n  ipfs log - Interact with the daemon log output.\n\nSYNOPSIS\n  ipfs log\n\nDESCRIPTION\n\n  'ipfs log' contains utility commands to affect or read the logging\n  output of a running daemon.\n  \n  There are also two environmental variables that direct the logging\n  system (not just for the daemon logs, but all commands):\n      GOLOG_LOG_LEVEL - sets the level of verbosity of the logging.\n          One of: debug, info, warn, error, dpanic, panic, fatal\n      GOLOG_LOG_FMT - sets formatting of the log output.\n          One of: color, nocolor, json\n\nSUBCOMMANDS\n  ipfs log level [<subsystem>] [<level>] - Change or get the logging level.\n  ipfs log ls                            - List the logging subsystems.\n\n  For more information about each command, use:\n  'ipfs log <subcmd> --help'\n\nEXPERIMENTAL SUBCOMMANDS\n  ipfs log tail - Read and output log messages."
    },
    {
      "subcommands": [],
      "options": [
        {
          "option": "--ipfs-path",
          "shortcut": "-f",
          "description": "The path where IPFS should be mounted.",
          "value": "string",
          "default": null
        },
        {
          "option": "--ipns-path",
          "shortcut": "-n",
          "description": "The path where IPNS should be mounted.",
          "value": "string",
          "default": null
        },
        {
          "option": "--mfs-path",
          "shortcut": "-m",
          "description": "The path where MFS should be mounted.",
          "value": "string",
          "default": null
        }
      ],
      "name": "ipfs mount",
      "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs mount - Mounts IPFS to the filesystem (read-only).\n\nSYNOPSIS\n  ipfs mount [--ipfs-path=<ipfs-path> | -f] [--ipns-path=<ipns-path> | -n]\n             [--mfs-path=<mfs-path> | -m]\n\nOPTIONS\n\n  -f, --ipfs-path  string - The path where IPFS should be mounted.\n  -n, --ipns-path  string - The path where IPNS should be mounted.\n  -m, --mfs-path   string - The path where MFS should be mounted.\n\nDESCRIPTION\n\n  Mount IPFS at a read-only mountpoint on the OS. The default, /ipfs and /ipns,\n  are set in the configuration file, but can be overridden by the options.\n  All IPFS objects will be accessible under this directory. Note that the\n  root will not be listable, as it is virtual. Access known paths directly.\n  \n  You may have to create /ipfs and /ipns before using 'ipfs mount':\n  \n  > sudo mkdir /ipfs /ipns /mfs\n  > sudo chown $(whoami) /ipfs /ipns /mfs\n  > ipfs daemon &\n  > ipfs mount\n  \n  Example:\n  \n  # setup\n  > mkdir foo\n  > echo \"baz\" > foo/bar\n  > ipfs add -r foo\n  added QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR foo/bar\n  added QmSh5e7S6fdcu75LAbXNZAFY2nGyZUJXyLCJDvn2zRkWyC foo\n  > ipfs ls QmSh5e7S6fdcu75LAbXNZAFY2nGyZUJXyLCJDvn2zRkWyC\n  QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR 12 bar\n  > ipfs cat QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR\n  baz\n  \n  # mount\n  > ipfs daemon &\n  > ipfs mount\n  IPFS mounted at: /ipfs\n  IPNS mounted at: /ipns\n  MFS  mounted at: /mfs\n  > cd /ipfs/QmSh5e7S6fdcu75LAbXNZAFY2nGyZUJXyLCJDvn2zRkWyC\n  > ls\n  bar\n  > cat bar\n  baz\n  > cat /ipfs/QmSh5e7S6fdcu75LAbXNZAFY2nGyZUJXyLCJDvn2zRkWyC/bar\n  baz\n  > cat /ipfs/QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR\n  baz",
      "description": "Mount an IPFS read-only mount point (experimental)"
    },
    {
      "description": "Encode and decode files or stdin with multibase format",
      "subcommands": [
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs multibase decode",
          "raw_help_text": "USAGE\n  ipfs multibase decode <encoded_file> - Decode multibase string\n\nSYNOPSIS\n  ipfs multibase decode [--] <encoded_file>\n\nARGUMENTS\n\n  <encoded_file> - encoded data to decode\n\nDESCRIPTION\n\n  This command expects multibase inside of a file or via stdin:\n  \n    > echo -n hello | ipfs multibase encode -b base16 > file\n    > cat file\n    f68656c6c6f\n  \n    > ipfs multibase decode file\n    hello\n  \n    > cat file | ipfs multibase decode\n    hello",
          "description": "Decode multibase string"
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--b",
              "shortcut": "-b",
              "description": "multibase encoding.",
              "value": "<b>",
              "default": "base64url"
            }
          ],
          "name": "ipfs multibase encode",
          "raw_help_text": "USAGE\n  ipfs multibase encode <file> - Encode data into multibase string\n\nSYNOPSIS\n  ipfs multibase encode [-b=<b>] [--] <file>\n\nARGUMENTS\n\n  <file> - data to encode\n\nOPTIONS\n\n  -b  string - multibase encoding. Default: base64url.\n\nDESCRIPTION\n\n  This command expects a file name or data provided via stdin.\n  \n  By default it will use URL-safe base64url encoding,\n  but one can customize used base with -b:\n  \n    > echo hello | ipfs multibase encode -b base16 > output_file\n    > cat output_file\n    f68656c6c6f0a\n  \n    > echo hello > input_file\n    > ipfs multibase encode -b base16 input_file\n    f68656c6c6f0a",
          "description": "Encode data into multibase string"
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--numeric",
              "shortcut": null,
              "description": "also include numeric codes.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--prefix",
              "shortcut": null,
              "description": "also include the single letter prefixes in addition to the code.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs multibase list",
          "raw_help_text": "USAGE\n  ipfs multibase list - List available multibase encodings.\n\nSYNOPSIS\n  ipfs multibase list [--prefix] [--numeric]\n\nOPTIONS\n\n  --prefix   bool - also include the single letter prefixes in addition to the\n                    code.\n  --numeric  bool - also include numeric codes.\n\nDESCRIPTION\n\n  'ipfs cid bases' relies on https://github.com/multiformats/go-multibase",
          "description": "List available multibase encodings"
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "-b",
              "shortcut": null,
              "description": "multibase encoding.",
              "value": "string",
              "default": "base64url"
            }
          ],
          "name": "ipfs multibase transcode",
          "raw_help_text": "USAGE\n  ipfs multibase transcode <encoded_file> - Transcode multibase string between\n                                            bases\n\nSYNOPSIS\n  ipfs multibase transcode [-b=<b>] [--] <encoded_file>\n\nARGUMENTS\n\n  <encoded_file> - encoded data to decode\n\nOPTIONS\n\n  -b  string - multibase encoding. Default: base64url.\n\nDESCRIPTION\n\n  This command expects multibase inside of a file or via stdin.\n  \n  By default it will use URL-safe base64url encoding,\n  but one can customize used base with -b:\n  \n    > echo -n hello | ipfs multibase encode > file\n    > cat file\n    uaGVsbG8\n  \n    > ipfs multibase transcode file -b base16 > transcoded_file\n    > cat transcoded_file\n    f68656c6c6f",
          "description": "Transcode multibase string between bases"
        }
      ],
      "options": [],
      "name": "ipfs multibase",
      "raw_help_text": "USAGE\n  ipfs multibase - Encode and decode files or stdin with multibase format\n\nSYNOPSIS\n  ipfs multibase\n\nSUBCOMMANDS\n  ipfs multibase decode <encoded_file>    - Decode multibase string\n  ipfs multibase encode <file>            - Encode data into multibase string\n  ipfs multibase list                     - List available multibase encodings.\n  ipfs multibase transcode <encoded_file> - Transcode multibase string between\n                                            bases\n\n  For more information about each command, use:\n  'ipfs multibase <subcmd> --help'"
    },
    {
      "subcommands": [
        {
          "subcommands": [],
          "options": [
            {
              "option": "--dump",
              "shortcut": null,
              "description": "Include a full hex dump of the raw Protobuf record.",
              "value": "false",
              "default": "true"
            },
            {
              "option": "--verify",
              "shortcut": null,
              "description": "CID of the public IPNS key to validate against.",
              "value": "string",
              "default": null
            }
          ],
          "description": "Inspects an IPNS Record",
          "name": "ipfs name inspect",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs name inspect <record> - Inspects an IPNS Record\n\nSYNOPSIS\n  ipfs name inspect [--verify=<verify>] [--dump=false] [--] <record>\n\nARGUMENTS\n\n  <record> - The IPNS record payload to be verified.\n\nOPTIONS\n\n  --verify  string - CID of the public IPNS key to validate against.\n  --dump    bool   - Include a full hex dump of the raw Protobuf record.\n                     Default: true.\n\nDESCRIPTION\n\n  Prints values inside of IPNS Record protobuf and its DAG-CBOR Data field.\n  \n  The input can be a file or STDIN, the output can be JSON:\n  \n    $ ipfs routing get \"/ipns/$PEERID\" > ipns_record\n    $ ipfs name inspect --enc=json < ipns_record\n  \n  Values in PublicKey, SignatureV1 and SignatureV2 fields are raw bytes encoded\n  in Multibase. The Data field is DAG-CBOR represented as DAG-JSON.\n  \n  Passing --verify will verify signature against provided public key."
        },
        {
          "subcommands": [
            {
              "subcommands": [],
              "options": [],
              "name": "ipfs name pubsub cancel",
              "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs name pubsub cancel <name> - Cancel a name subscription.\n\nSYNOPSIS\n  ipfs name pubsub cancel [--] <name>\n\nARGUMENTS\n\n  <name> - Name to cancel the subscription for.",
              "description": "Cancel a name subscription."
            },
            {
              "subcommands": [],
              "options": [],
              "name": "ipfs name pubsub state",
              "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs name pubsub state - Query the state of IPNS pubsub.\n\nSYNOPSIS\n  ipfs name pubsub state",
              "description": "Query the state of IPNS pubsub."
            },
            {
              "subcommands": [],
              "options": [
                {
                  "option": "--ipns-base",
                  "shortcut": null,
                  "description": "Encoding used for keys: Can either be a multibase encoded CID or a base58btc encoded multihash. Takes {b58mh|base36|k|base32|b...}.",
                  "value": "string",
                  "default": "base36"
                }
              ],
              "name": "ipfs name pubsub subs",
              "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs name pubsub subs - Show current name subscriptions.\n\nSYNOPSIS\n  ipfs name pubsub subs [--ipns-base=<ipns-base>]\n\nOPTIONS\n\n  --ipns-base  string - Encoding used for keys: Can either be a multibase\n                        encoded CID or a base58btc encoded multihash. Takes\n                        {b58mh|base36|k|base32|b...}. Default: base36.",
              "description": "Show current name subscriptions."
            }
          ],
          "options": [],
          "name": "ipfs name pubsub",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs name pubsub - IPNS pubsub management\n\nSYNOPSIS\n  ipfs name pubsub\n\nDESCRIPTION\n\n  Manage and inspect the state of the IPNS pubsub resolver.\n  \n  Note: this command is experimental and subject to change as the system is refined\n\nEXPERIMENTAL SUBCOMMANDS\n  ipfs name pubsub cancel <name> - Cancel a name subscription.\n  ipfs name pubsub state         - Query the state of IPNS pubsub.\n  ipfs name pubsub subs          - Show current name subscriptions.",
          "description": "IPNS pubsub management"
        },
        {
          "description": "Publish IPNS names.",
          "subcommands": [],
          "options": [
            {
              "option": "--allow-delegated",
              "shortcut": null,
              "description": "Allow publishing without DHT connectivity - uses local datastore and HTTP delegated publishers only.",
              "value": null,
              "default": null
            },
            {
              "option": "--allow-offline",
              "shortcut": null,
              "description": "Allow publishing when offline - publishes to local datastore without requiring network connectivity.",
              "value": null,
              "default": null
            },
            {
              "option": "--ipns-base",
              "shortcut": null,
              "description": "Encoding used for keys: Can either be a multibase encoded CID or a base58btc encoded multihash. Takes {b58mh|base36|k|base32|b...}.",
              "value": "<ipns-base>",
              "default": "base36"
            },
            {
              "option": "--key",
              "shortcut": "-k",
              "description": "Name of the key to be used or a valid PeerID, as listed by 'ipfs key list -l'.",
              "value": "<key>",
              "default": "self"
            },
            {
              "option": "--lifetime",
              "shortcut": "-t",
              "description": "Time duration the signed record will be valid for. Accepts durations such as \"300s\", \"1.5h\" or \"7d2h45m\".",
              "value": "<lifetime>",
              "default": "48h0m0s"
            },
            {
              "option": "--quieter",
              "shortcut": "-Q",
              "description": "Write only final IPNS Name encoded as CIDv1 (for use in /ipns content paths).",
              "value": null,
              "default": null
            },
            {
              "option": "--resolve",
              "shortcut": null,
              "description": "Check if the given path can be resolved before publishing.",
              "value": "false",
              "default": "true"
            },
            {
              "option": "--sequence",
              "shortcut": null,
              "description": "Set a custom sequence number for the IPNS record (must be higher than current).",
              "value": "<sequence>",
              "default": null
            },
            {
              "option": "--ttl",
              "shortcut": null,
              "description": "Time duration hint, akin to --lifetime, indicating how long to cache this record before checking for updates.",
              "value": "<ttl>",
              "default": "5m0s"
            },
            {
              "option": "--v1compat",
              "shortcut": null,
              "description": "Produce a backward-compatible IPNS Record by including fields for both V1 and V2 signatures.",
              "value": null,
              "default": "true"
            }
          ],
          "name": "ipfs name publish",
          "raw_help_text": "USAGE\n  ipfs name publish <ipfs-path> - Publish IPNS names.\n\nSYNOPSIS\n  ipfs name publish [--key=<key> | -k] [--resolve=false]\n                    [--lifetime=<lifetime> | -t] [--ttl=<ttl>] [--quieter | -Q]\n                    [--v1compat=false] [--allow-offline] [--allow-delegated]\n                    [--sequence=<sequence>] [--ipns-base=<ipns-base>] [--]\n                    <ipfs-path>\n\nARGUMENTS\n\n  <ipfs-path> - ipfs path of the object to be published.\n\nOPTIONS\n\n  -k, --key          string - Name of the key to be used or a valid PeerID, as\n                              listed by 'ipfs key list -l'. Default: self.\n  --resolve          bool   - Check if the given path can be resolved before\n                              publishing. Default: true.\n  -t, --lifetime     string - Time duration the signed record will be valid\n                              for. Accepts durations such as \"300s\", \"1.5h\" or\n                              \"7d2h45m\". Default: 48h0m0s.\n  --ttl              string - Time duration hint, akin to --lifetime,\n                              indicating how long to cache this record before\n                              checking for updates. Default: 5m0s.\n  -Q, --quieter      bool   - Write only final IPNS Name encoded as CIDv1 (for\n                              use in /ipns content paths).\n  --v1compat         bool   - Produce a backward-compatible IPNS Record by\n                              including fields for both V1 and V2 signatures.\n                              Default: true.\n  --allow-offline    bool   - Allow publishing when offline - publishes to\n                              local datastore without requiring network\n                              connectivity.\n  --allow-delegated  bool   - Allow publishing without DHT connectivity - uses\n                              local datastore and HTTP delegated publishers\n                              only.\n  --sequence         uint64 - Set a custom sequence number for the IPNS record\n                              (must be higher than current).\n  --ipns-base        string - Encoding used for keys: Can either be a multibase\n                              encoded CID or a base58btc encoded multihash.\n                              Takes {b58mh|base36|k|base32|b...}. Default:\n                              base36.\n\nDESCRIPTION\n\n  IPNS is a PKI namespace, where names are the hashes of public keys, and\n  the private key enables publishing new (signed) values. In both publish\n  and resolve, the default name used is the node's own PeerID,\n  which is the hash of its public key.\n  \n  You can use the 'ipfs key' commands to list and generate more names and their\n  respective keys.\n  \n  Publishing Modes:\n  \n  By default, IPNS records are published to both the DHT and any configured\n  HTTP delegated publishers. You can control this behavior with the following flags:\n  \n    --allow-offline    Allow publishing when offline (publishes to local datastore, network operations are optional)\n    --allow-delegated  Allow publishing without DHT connectivity (local + HTTP delegated publishers only)\n  \n  Examples:\n  \n  Publish an <ipfs-path> with your default name:\n  \n    > ipfs name publish /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    Published to QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n: /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Publish without DHT (HTTP delegated publishers only):\n  \n    > ipfs name publish --allow-delegated /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    Published to QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n: /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Publish when offline (local publish, network optional):\n  \n    > ipfs name publish --allow-offline /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    Published to QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n: /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Notes:\n  \n  The --ttl option specifies the time duration for caching IPNS records.\n  Lower values like '1m' enable faster updates but increase network load,\n  while the default of 1 hour reduces traffic but may delay propagation.\n  Gateway operators may override this with Ipns.MaxCacheTTL configuration.\n  \n  The --sequence option sets a custom sequence number for the IPNS record.\n  The sequence number must be monotonically increasing (greater than the\n  current record's sequence). This is useful for manually coordinating\n  updates across multiple writers. If not specified, the sequence number\n  increments automatically.\n  \n  For faster IPNS updates, consider:\n  - Using a lower --ttl value (e.g., '1m' for quick updates)\n  - Enabling PubSub via Ipns.UsePubsub in the config"
        },
        {
          "description": "Resolve IPNS names.",
          "subcommands": [],
          "options": [
            {
              "option": "--dhtrc",
              "shortcut": "-n",
              "description": "Number of records to request for DHT resolution. Default: 16.",
              "value": "<dht-record-count>",
              "default": "16"
            },
            {
              "option": "--dht-timeout",
              "shortcut": "--dhtt",
              "description": "Max time to collect values during DHT resolution e.g. \"30s\". Pass 0 for no timeout. Default: 1m0s.",
              "value": "<dht-timeout>",
              "default": "1m0s"
            },
            {
              "option": "--nocache",
              "shortcut": "-n",
              "description": "Do not use cached entries.",
              "value": null,
              "default": null
            },
            {
              "option": "--recursive",
              "shortcut": "-r",
              "description": "Resolve until the result is not an IPNS name. Default: true.",
              "value": null,
              "default": "true"
            },
            {
              "option": "--stream",
              "shortcut": "-s",
              "description": "Stream entries as they are found.",
              "value": null,
              "default": null
            }
          ],
          "name": "ipfs name resolve",
          "raw_help_text": "USAGE\n  ipfs name resolve [<name>] - Resolve IPNS names.\n\nSYNOPSIS\n  ipfs name resolve [--recursive=false] [--nocache | -n]\n                    [--dht-record-count=<dht-record-count> | --dhtrc]\n                    [--dht-timeout=<dht-timeout> | --dhtt] [--stream | -s] [--]\n                    [<name>]\n\nARGUMENTS\n\n  [<name>] - The IPNS name to resolve. Defaults to your node's peerID.\n\nOPTIONS\n\n  -r, --recursive              bool   - Resolve until the result is not an IPNS\n                                        name. Default: true.\n  -n, --nocache                bool   - Do not use cached entries.\n  --dhtrc, --dht-record-count  uint   - Number of records to request for DHT\n                                        resolution. Default: 16.\n  --dhtt, --dht-timeout        string - Max time to collect values during DHT\n                                        resolution e.g. \"30s\". Pass 0 for no\n                                        timeout. Default: 1m0s.\n  -s, --stream                 bool   - Stream entries as they are found.\n\nDESCRIPTION\n\n  IPNS is a PKI namespace, where names are the hashes of public keys, and\n  the private key enables publishing new (signed) values. In both publish\n  and resolve, the default name used is the node's own PeerID,\n  which is the hash of its public key.\n  \n  You can use the 'ipfs key' commands to list and generate more names and their\n  respective keys.\n  \n  Examples:\n  \n  Resolve the value of your name:\n  \n    > ipfs name resolve\n    /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Resolve the value of another name:\n  \n    > ipfs name resolve QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ\n    /ipfs/QmSiTko9JZyabH56y2fussEt1A5oDqsFXB3CkvAqraFryz\n  \n  Resolve the value of a dnslink:\n  \n    > ipfs name resolve ipfs.io\n    /ipfs/QmaBvfZooxWkrv7D3r8LS9moNjzD2o525XMZze69hhoxf5"
        }
      ],
      "options": [],
      "name": "ipfs name",
      "raw_help_text": "USAGE\n  ipfs name - Publish and resolve IPNS names.\n\nSYNOPSIS\n  ipfs name\n\nDESCRIPTION\n\n  IPNS is a PKI namespace, where names are the hashes of public keys, and\n  the private key enables publishing new (signed) values. In both publish\n  and resolve, the default name used is the node's own PeerID,\n  which is the hash of its public key.\n  \n  You can use the 'ipfs key' commands to list and generate more names and their\n  respective keys.\n  \n  Examples:\n  \n  Publish an <ipfs-path> with your default name:\n  \n    > ipfs name publish /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    Published to QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n: /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Publish an <ipfs-path> with another name, added by an 'ipfs key' command:\n  \n    > ipfs key gen --type=rsa --size=2048 mykey\n    > ipfs name publish --key=mykey /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    Published to QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd: /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Resolve the value of your name:\n  \n    > ipfs name resolve\n    /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Resolve the value of another name:\n  \n    > ipfs name resolve QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ\n    /ipfs/QmSiTko9JZyabH56y2fussEt1A5oDqsFXB3CkvAqraFryz\n  \n  Resolve the value of a dnslink:\n  \n    > ipfs name resolve ipfs.io\n    /ipfs/QmaBvfZooxWkrv7D3r8LS9moNjzD2o525XMZze69hhoxf5\n\nSUBCOMMANDS\n  ipfs name publish <ipfs-path> - Publish IPNS names.\n  ipfs name resolve [<name>]    - Resolve IPNS names.\n\n  For more information about each command, use:\n  'ipfs name <subcmd> --help'\n\nEXPERIMENTAL SUBCOMMANDS\n  ipfs name inspect <record> - Inspects an IPNS Record\n  ipfs name pubsub           - IPNS pubsub management",
      "description": "Publish and resolve IPNS names"
    },
    {
      "subcommands": [],
      "options": [
        {
          "option": "--count",
          "shortcut": "-n",
          "description": "Number of ping messages to send.",
          "value": "int",
          "default": "10"
        }
      ],
      "name": "ipfs ping",
      "raw_help_text": "USAGE\n  ipfs ping <peer ID>... - Send echo request packets to IPFS hosts.\n\nSYNOPSIS\n  ipfs ping [--count=<count> | -n] [--] <peer ID>...\n\nARGUMENTS\n\n  <peer ID>... - ID of peer to be pinged.\n\nOPTIONS\n\n  -n, --count  int - Number of ping messages to send. Default: 10.\n\nDESCRIPTION\n\n  'ipfs ping' is a tool to test sending data to other nodes. It finds nodes\n  via the routing system, sends pings, waits for pongs, and prints out round-\n  trip latency information.",
      "description": "Measure the latency of a connection"
    },
    {
      "description": "Pin (and unpin) objects to local storage.",
      "subcommands": [
        {
          "description": "Pin objects to local storage.",
          "subcommands": [],
          "options": [
            {
              "option": "--name",
              "shortcut": "-n",
              "description": "An optional name for created pin(s).",
              "value": "<name>",
              "default": null
            },
            {
              "option": "--progress",
              "shortcut": null,
              "description": "Show progress.",
              "value": null,
              "default": null
            },
            {
              "option": "--recursive",
              "shortcut": "-r",
              "description": "Recursively pin the object linked to by the specified object(s).",
              "value": "bool",
              "default": "true"
            }
          ],
          "name": "ipfs pin add",
          "raw_help_text": "USAGE\n  ipfs pin add <ipfs-path>... - Pin objects to local storage.\n\nSYNOPSIS\n  ipfs pin add [--recursive=false] [--name=<name> | -n] [--progress] [--]\n               <ipfs-path>...\n\nARGUMENTS\n\n  <ipfs-path>... - Path to object(s) to be pinned.\n\nOPTIONS\n\n  -r, --recursive  bool   - Recursively pin the object linked to by the\n                            specified object(s). Default: true.\n  -n, --name       string - An optional name for created pin(s).\n  --progress       bool   - Show progress.\n\nDESCRIPTION\n\n  Create a pin for the given object, protecting resolved CID from being garbage\n  collected.\n  \n  An optional name can be provided, and read back via 'ipfs pin ls --names'.\n  \n  Be mindful of defaults:\n  \n  Default pin type is 'recursive' (entire DAG).\n  Pass -r=false to create a direct pin for a single block.\n  Use 'pin ls -t recursive' to only list roots of recursively pinned DAGs\n  (significantly faster when many big DAGs are pinned recursively)\n  \n  Default pin name is empty. Pass '--name' to 'pin add' to set one\n  and use 'pin ls --names' to see it. Pinning a second time with a different\n  name will update the name of the pin.\n  \n  If daemon is running, any missing blocks will be retrieved from the network.\n  It may take some time. Pass '--progress' to track the progress."
        },
        {
          "description": "List objects pinned to local storage.",
          "subcommands": [],
          "options": [
            {
              "option": "--names",
              "shortcut": null,
              "description": "Include pin names in the output (slower, disabled by default).",
              "value": null,
              "default": null
            },
            {
              "option": "--quiet",
              "shortcut": "-q",
              "description": "Output only the CIDs of pins.",
              "value": null,
              "default": null
            },
            {
              "option": "--type",
              "shortcut": "-t",
              "description": "The type of pinned keys to list. Can be \"direct\", \"indirect\", \"recursive\", or \"all\". Default: all.",
              "value": "<type>",
              "default": "all"
            },
            {
              "option": "--name",
              "shortcut": "-n",
              "description": "Limit returned pins to ones with names that contain the value provided (case-sensitive, partial match). Implies --names=true.",
              "value": "<name>",
              "default": null
            },
            {
              "option": "--stream",
              "shortcut": "-s",
              "description": "Enable streaming of pins as they are discovered.",
              "value": null,
              "default": null
            }
          ],
          "name": "ipfs pin ls",
          "raw_help_text": "USAGE\n  ipfs pin ls [<ipfs-path>]... - List objects pinned to local storage.\n\nSYNOPSIS\n  ipfs pin ls [--type=<type> | -t] [--quiet | -q] [--name=<name> | -n]\n              [--stream | -s] [--names] [--] [<ipfs-path>...]\n\nARGUMENTS\n\n  [<ipfs-path>]... - Path to object(s) to be listed.\n\nOPTIONS\n\n  -t, --type    string - The type of pinned keys to list. Can be \"direct\",\n                         \"indirect\", \"recursive\", or \"all\". Default: all.\n  -q, --quiet   bool   - Output only the CIDs of pins.\n  -n, --name    string - Limit returned pins to ones with names that contain\n                         the value provided (case-sensitive, partial match).\n                         Implies --names=true.\n  -s, --stream  bool   - Enable streaming of pins as they are discovered.\n  --names       bool   - Include pin names in the output (slower, disabled by\n                         default).\n\nDESCRIPTION\n\n  Returns a list of objects that are pinned locally.\n  \n  By default, all pinned objects are returned, but the '--type' flag or\n  arguments can restrict that to a specific pin type or to some specific objects\n  respectively.\n  \n  Use --type=<type> to specify the type of pinned keys to list.\n  Valid values are:\n      * \"direct\": pin that specific object.\n      * \"recursive\": pin that specific object, and indirectly pin all its\n        descendants\n      * \"indirect\": pinned indirectly by an ancestor (like a refcount)\n      * \"all\"\n  \n  By default, pin names are not included (returned as empty).\n  Pass '--names' flag to return pin names (set with '--name' from 'pin add').\n  \n  With arguments, the command fails if any of the arguments is not a pinned\n  object. And if --type=<type> is additionally used, the command will also fail\n  if any of the arguments is not of the specified type.\n  \n  Example:\n  \t$ echo \"hello\" | ipfs add -q\n  \tQmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN\n  \t$ ipfs pin ls\n  \tQmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN recursive\n  \t# now remove the pin, and repin it directly\n  \t$ ipfs pin rm QmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN\n  \tunpinned QmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN\n  \t$ ipfs pin add -r=false QmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN\n  \tpinned QmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN directly\n  \t$ ipfs pin ls --type=direct\n  \tQmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN direct\n  \t$ ipfs pin ls QmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN\n  \tQmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN direct"
        },
        {
          "description": "Pin (and unpin) objects to remote pinning service.",
          "subcommands": [
            {
              "subcommands": [],
              "options": [
                {
                  "option": "--background",
                  "shortcut": null,
                  "description": "Add to the queue on the remote service and return immediately (does not wait for pinned status).",
                  "value": "bool",
                  "default": "false"
                },
                {
                  "option": "--name",
                  "shortcut": null,
                  "description": "An optional name for the pin.",
                  "value": "string",
                  "default": null
                },
                {
                  "option": "--service",
                  "shortcut": null,
                  "description": "Name of the remote pinning service to use (mandatory).",
                  "value": "string",
                  "default": null
                }
              ],
              "name": "ipfs pin remote add",
              "raw_help_text": "USAGE\n  ipfs pin remote add <ipfs-path> - Pin object to remote pinning service.\n\nSYNOPSIS\n  ipfs pin remote add [--service=<service>] [--name=<name>] [--background] [--]\n                      <ipfs-path>\n\nARGUMENTS\n\n  <ipfs-path> - CID or Path to be pinned.\n\nOPTIONS\n\n  --service     string - Name of the remote pinning service to use (mandatory).\n  --name        string - An optional name for the pin.\n  --background  bool   - Add to the queue on the remote service and return\n                         immediately (does not wait for pinned status).\n                         Default: false.\n\nDESCRIPTION\n\n  Asks remote pinning service to pin an IPFS object from a given path or a CID.\n  \n  To pin CID 'bafkqaaa' to service named 'mysrv' under a pin named 'mypin':\n  \n    $ ipfs pin remote add --service=mysrv --name=mypin bafkqaaa\n  \n  The above command will block until remote service returns 'pinned' status,\n  which may take time depending on the size and available providers of the pinned\n  data.\n  \n  If you prefer to not wait for pinning confirmation and return immediately\n  after remote service confirms 'queued' status, add the '--background' flag:\n  \n    $ ipfs pin remote add --service=mysrv --name=mypin --background bafkqaaa\n  \n  Status of background pin requests can be inspected with the 'ls' command.\n  \n  To list all pins for the CID across all statuses:\n  \n    $ ipfs pin remote ls --service=mysrv --cid=bafkqaaa --status=queued \\\n        --status=pinning --status=pinned --status=failed\n  \n  NOTE: a comma-separated notation is supported in CLI for convenience:\n  \n    $ ipfs pin remote ls --service=mysrv --cid=bafkqaaa --status=queued,pinning,pinned,failed",
              "description": "Pin object to remote pinning service."
            },
            {
              "description": "List objects pinned to remote pinning service.",
              "subcommands": [],
              "options": [
                {
                  "option": "--cid",
                  "shortcut": null,
                  "description": "Return pins for the specified CIDs (comma-separated).",
                  "value": "array",
                  "default": null
                },
                {
                  "option": "--name",
                  "shortcut": null,
                  "description": "Return pins with names that contain the value provided (case-sensitive, exact match).",
                  "value": "string",
                  "default": null
                },
                {
                  "option": "--service",
                  "shortcut": null,
                  "description": "Name of the remote pinning service to use (mandatory).",
                  "value": "string",
                  "default": null
                },
                {
                  "option": "--status",
                  "shortcut": null,
                  "description": "Return pins with the specified statuses (queued,pinning,pinned,failed). Default: [pinned].",
                  "value": "array",
                  "default": "[pinned]"
                }
              ],
              "name": "ipfs pin remote ls",
              "raw_help_text": "USAGE\n  ipfs pin remote ls - List objects pinned to remote pinning service.\n\nSYNOPSIS\n  ipfs pin remote ls [--service=<service>] [--name=<name>] [--cid=<cid>]...\n                     [--status=<status>]...\n\nOPTIONS\n\n  --service  string - Name of the remote pinning service to use (mandatory).\n  --name     string - Return pins with names that contain the value provided\n                      (case-sensitive, exact match).\n  --cid      array  - Return pins for the specified CIDs (comma-separated).\n  --status   array  - Return pins with the specified statuses\n                      (queued,pinning,pinned,failed). Default: [pinned].\n\nDESCRIPTION\n\n  Returns a list of objects that are pinned to a remote pinning service.\n  \n  NOTE: By default, it will only show matching objects in 'pinned' state.\n  Pass '--status=queued,pinning,pinned,failed' to list pins in all states."
            },
            {
              "subcommands": [],
              "options": [
                {
                  "option": "--cid",
                  "shortcut": null,
                  "description": "Remove pins for the specified CIDs.",
                  "value": "array",
                  "default": null
                },
                {
                  "option": "--force",
                  "shortcut": null,
                  "description": "Allow removal of multiple pins matching the query without additional confirmation.",
                  "value": "bool",
                  "default": "false"
                },
                {
                  "option": "--name",
                  "shortcut": null,
                  "description": "Remove pins with names that contain provided value (case-sensitive, exact match).",
                  "value": "string",
                  "default": null
                },
                {
                  "option": "--service",
                  "shortcut": null,
                  "description": "Name of the remote pinning service to use (mandatory).",
                  "value": "string",
                  "default": null
                },
                {
                  "option": "--status",
                  "shortcut": null,
                  "description": "Remove pins with the specified statuses (queued,pinning,pinned,failed).",
                  "value": "array",
                  "default": "[pinned]"
                }
              ],
              "name": "ipfs pin remote rm",
              "raw_help_text": "USAGE\n  ipfs pin remote rm - Remove pins from remote pinning service.\n\nSYNOPSIS\n  ipfs pin remote rm [--service=<service>] [--name=<name>] [--cid=<cid>]...\n                     [--status=<status>]... [--force]\n\nOPTIONS\n\n  --service  string - Name of the remote pinning service to use (mandatory).\n  --name     string - Remove pins with names that contain provided value\n                      (case-sensitive, exact match).\n  --cid      array  - Remove pins for the specified CIDs.\n  --status   array  - Remove pins with the specified statuses\n                      (queued,pinning,pinned,failed). Default: [pinned].\n  --force    bool   - Allow removal of multiple pins matching the query without\n                      additional confirmation. Default: false.\n\nDESCRIPTION\n\n  Removes remote pins, allowing them to be garbage-collected if needed.\n  \n  This command accepts the same search query parameters as 'ls', and it is good\n  practice to execute 'ls' before 'rm' to confirm the list of pins to be removed.\n  \n  To remove a single pin for a specific CID:\n  \n    $ ipfs pin remote ls --service=mysrv --cid=bafkqaaa\n    $ ipfs pin remote rm --service=mysrv --cid=bafkqaaa\n  \n  When more than one pin matches the query on the remote service, an error is\n  returned.  To confirm the removal of multiple pins, pass '--force':\n  \n    $ ipfs pin remote ls --service=mysrv --name=popular-name\n    $ ipfs pin remote rm --service=mysrv --name=popular-name --force\n  \n  NOTE: When no '--status' is passed, implicit '--status=pinned' is used.\n  To list and then remove all pending pin requests, pass an explicit status list:\n  \n    $ ipfs pin remote ls --service=mysrv --status=queued,pinning,failed\n    $ ipfs pin remote rm --service=mysrv --status=queued,pinning,failed --force",
              "description": "Remove pins from remote pinning service."
            },
            {
              "description": "Configure remote pinning services.",
              "subcommands": [
                {
                  "subcommands": [],
                  "options": [],
                  "name": "ipfs pin remote service add",
                  "raw_help_text": "USAGE\n  ipfs pin remote service add <service> <endpoint> <key> - Add remote pinning service.\n\nSYNOPSIS\n  ipfs pin remote service add [--] <service> <endpoint> <key>\n\nARGUMENTS\n\n  <service>  - Service name.\n  <endpoint> - Service endpoint.\n  <key>      - Service key.\n\nDESCRIPTION\n\n  Add credentials for access to a remote pinning service and store them in the\n  config under Pinning.RemoteServices map.\n  \n  TIP:\n  \n    To add services and test them by fetching pin count stats:\n  \n    $ ipfs pin remote service add goodsrv https://pin-api.example.com secret-key\n    $ ipfs pin remote service add badsrv  https://bad-api.example.com invalid-key\n    $ ipfs pin remote service ls --stat\n    goodsrv   https://pin-api.example.com 0/0/0/0\n    badsrv    https://bad-api.example.com invalid",
                  "description": "Add remote pinning service."
                },
                {
                  "subcommands": [],
                  "options": [
                    {
                      "option": "--stat",
                      "shortcut": null,
                      "description": "Try to fetch and display current pin count on remote service (queued/pinning/pinned/failed).",
                      "value": "bool",
                      "default": "false"
                    }
                  ],
                  "name": "ipfs pin remote service ls",
                  "raw_help_text": "USAGE\n  ipfs pin remote service ls - List remote pinning services.\n\nSYNOPSIS\n  ipfs pin remote service ls [--stat]\n\nOPTIONS\n\n  --stat  bool - Try to fetch and display current pin count on remote service\n                 (queued/pinning/pinned/failed). Default: false.\n\nDESCRIPTION\n\n  List remote pinning services.\n  \n  By default, only a name and an endpoint are listed; however, one can pass\n  '--stat' to test each endpoint by fetching pin counts for each state:\n  \n    $ ipfs pin remote service ls --stat\n    goodsrv   https://pin-api.example.com 0/0/0/0\n    badsrv    https://bad-api.example.com invalid\n  \n  TIP: pass '--enc=json' for more useful JSON output.",
                  "description": "List remote pinning services."
                },
                {
                  "subcommands": [],
                  "options": [],
                  "name": "ipfs pin remote service rm",
                  "raw_help_text": "USAGE\n  ipfs pin remote service rm <service> - Remove remote pinning service.\n\nSYNOPSIS\n  ipfs pin remote service rm [--] <service>\n\nARGUMENTS\n\n  <service> - Name of remote pinning service to remove.\n\nDESCRIPTION\n\n  Remove credentials for access to a remote pinning service.",
                  "description": "Remove remote pinning service."
                }
              ],
              "options": [],
              "name": "ipfs pin remote service",
              "raw_help_text": "USAGE\n  ipfs pin remote service - Configure remote pinning services.\n\nSYNOPSIS\n  ipfs pin remote service\n\nSUBCOMMANDS\n  ipfs pin remote service add <service> <endpoint> <key> - Add remote pinning service.\n  ipfs pin remote service ls                             - List remote pinning services.\n  ipfs pin remote service rm <service>                   - Remove remote pinning service.\n\n  For more information about each command, use:\n  'ipfs pin remote service <subcmd> --help'"
            }
          ],
          "options": [],
          "name": "ipfs pin remote",
          "raw_help_text": "USAGE\n  ipfs pin remote - Pin (and unpin) objects to remote pinning service.\n\nSYNOPSIS\n  ipfs pin remote\n\nSUBCOMMANDS\n  ipfs pin remote add <ipfs-path> - Pin object to remote pinning service.\n  ipfs pin remote ls              - List objects pinned to remote pinning\n                                    service.\n  ipfs pin remote rm              - Remove pins from remote pinning service.\n  ipfs pin remote service         - Configure remote pinning services.\n\n  For more information about each command, use:\n  'ipfs pin remote <subcmd> --help'"
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--recursive",
              "shortcut": "-r",
              "description": "Recursively unpin the object linked to by the specified object(s).",
              "value": "bool",
              "default": "true"
            }
          ],
          "description": "Removes the pin from the given object allowing it to be garbage collected if needed.",
          "name": "ipfs pin rm",
          "raw_help_text": "USAGE\n  ipfs pin rm <ipfs-path>... - Remove object from pin-list.\n\nSYNOPSIS\n  ipfs pin rm [--recursive=false] [--] <ipfs-path>...\n\nARGUMENTS\n\n  <ipfs-path>... - Path to object(s) to be unpinned.\n\nOPTIONS\n\n  -r, --recursive  bool - Recursively unpin the object linked to by the\n                          specified object(s). Default: true.\n\nDESCRIPTION\n\n  Removes the pin from the given object allowing it to be garbage\n  collected if needed. (By default, recursively. Use -r=false for direct pins.)\n  \n  A pin may not be removed because the specified object is not pinned or pinned\n  indirectly. To determine if the object is pinned indirectly, use the command:\n  ipfs pin ls -t indirect <cid>"
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--unpin",
              "shortcut": "-u",
              "description": "Remove the old pin.",
              "value": "bool",
              "default": "true"
            }
          ],
          "name": "ipfs pin update",
          "raw_help_text": "USAGE\n  ipfs pin update <from-path> <to-path> - Update a recursive pin.\n\nSYNOPSIS\n  ipfs pin update [--unpin=false] [--] <from-path> <to-path>\n\nARGUMENTS\n\n  <from-path> - Path to old object.\n  <to-path>   - Path to a new object to be pinned.\n\nOPTIONS\n\n  --unpin  bool - Remove the old pin. Default: true.\n\nDESCRIPTION\n\n  Efficiently pins a new object based on differences from an existing one and,\n  by default, removes the old pin.\n  \n  This command is useful when the new pin contains many similarities or is a\n  derivative of an existing one, particularly for large objects. This allows a more\n  efficient DAG-traversal which fully skips already-pinned branches from the old\n  object. As a requirement, the old object needs to be an existing recursive\n  pin.",
          "description": "Update a recursive pin."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--quiet",
              "shortcut": "-q",
              "description": "Write just hashes of broken pins.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--verbose",
              "shortcut": null,
              "description": "Also write the hashes of non-broken pins.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs pin verify",
          "raw_help_text": "USAGE\n  ipfs pin verify - Verify that recursive pins are complete.\n\nSYNOPSIS\n  ipfs pin verify [--verbose] [--quiet | -q]\n\nOPTIONS\n\n  --verbose    bool - Also write the hashes of non-broken pins.\n  -q, --quiet  bool - Write just hashes of broken pins.",
          "description": "Verify that recursive pins are complete."
        }
      ],
      "options": [],
      "name": "ipfs pin",
      "raw_help_text": "USAGE\n  ipfs pin - Pin (and unpin) objects to local storage.\n\nSYNOPSIS\n  ipfs pin\n\nSUBCOMMANDS\n  ipfs pin add <ipfs-path>...           - Pin objects to local storage.\n  ipfs pin ls [<ipfs-path>]...          - List objects pinned to local storage.\n  ipfs pin remote                       - Pin (and unpin) objects to remote\n                                          pinning service.\n  ipfs pin rm <ipfs-path>...            - Remove object from pin-list.\n  ipfs pin update <from-path> <to-path> - Update a recursive pin.\n  ipfs pin verify                       - Verify that recursive pins are\n                                          complete.\n\n  For more information about each command, use:\n  'ipfs pin <subcmd> --help'"
    },
    {
      "description": "Control and monitor content providing",
      "subcommands": [
        {
          "subcommands": [],
          "options": [
            {
              "option": "--quiet",
              "shortcut": "-q",
              "description": "Do not write output.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs provide clear",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs provide clear - Clear all CIDs from the provide queue.\n\nSYNOPSIS\n  ipfs provide clear [--quiet | -q]\n\nOPTIONS\n\n  -q, --quiet  bool - Do not write output.\n\nDESCRIPTION\n\n  Clear all CIDs pending to be provided for the first time.\n  \n  BEHAVIOR:\n  \n  This command removes CIDs from the provide queue that are waiting to be\n  advertised to the DHT for the first time. It does not affect content that\n  is already being reprovided on schedule.\n  \n  AUTOMATIC CLEARING:\n  \n  Kubo will automatically clear the queue when it detects a change of\n  Provide.Strategy upon a restart.\n  \n  Learn: https://github.com/ipfs/kubo/blob/master/docs/config.md#providestrategy",
          "description": "Clear all CIDs from the provide queue."
        },
        {
          "description": "Show statistics about the provider system",
          "subcommands": [],
          "options": [
            {
              "option": "--all",
              "shortcut": "-a",
              "description": "Display all provide sweep stats.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--compact",
              "shortcut": null,
              "description": "Display stats in 2-column layout (requires --all).",
              "value": "bool",
              "default": null
            },
            {
              "option": "--connectivity",
              "shortcut": null,
              "description": "Display DHT connectivity status.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--lan",
              "shortcut": null,
              "description": "Show stats for LAN DHT only (for Sweep+Dual DHT only).",
              "value": "bool",
              "default": null
            },
            {
              "option": "--network",
              "shortcut": null,
              "description": "Display network stats (peers, reachability, region size).",
              "value": "bool",
              "default": null
            },
            {
              "option": "--operations",
              "shortcut": null,
              "description": "Display operation stats (ongoing/past provides, rates, errors).",
              "value": "bool",
              "default": null
            },
            {
              "option": "--queues",
              "shortcut": null,
              "description": "Display provide and reprovide queue sizes.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--schedule",
              "shortcut": null,
              "description": "Display reprovide schedule (CIDs/regions scheduled, next reprovide time).",
              "value": "bool",
              "default": null
            },
            {
              "option": "--timings",
              "shortcut": null,
              "description": "Display timing information (uptime, cycle start, reprovide interval).",
              "value": "bool",
              "default": null
            },
            {
              "option": "--workers",
              "shortcut": null,
              "description": "Display worker pool stats (active/available/queued workers).",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs provide stat",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs provide stat - Show statistics about the provider system\n\nSYNOPSIS\n  ipfs provide stat [--lan] [--all | -a] [--compact] [--connectivity]\n                    [--network] [--schedule] [--timings] [--workers]\n                    [--operations] [--queues]\n\nOPTIONS\n\n  --lan           bool - Show stats for LAN DHT only (for Sweep+Dual DHT only).\n  -a, --all       bool - Display all provide sweep stats.\n  --compact       bool - Display stats in 2-column layout (requires --all).\n  --connectivity  bool - Display DHT connectivity status.\n  --network       bool - Display network stats (peers, reachability, region\n                         size).\n  --schedule      bool - Display reprovide schedule (CIDs/regions scheduled,\n                         next reprovide time).\n  --timings       bool - Display timing information (uptime, cycle start,\n                         reprovide interval).\n  --workers       bool - Display worker pool stats (active/available/queued\n                         workers).\n  --operations    bool - Display operation stats (ongoing/past provides, rates,\n                         errors).\n  --queues        bool - Display provide and reprovide queue sizes.\n\nDESCRIPTION\n\n  Returns statistics about the node's provider system.\n  \n  OVERVIEW:\n  \n  The provide system advertises content to the DHT by publishing provider\n  records that map CIDs to your peer ID. These records expire after a fixed\n  TTL to account for node churn, so content must be reprovided periodically\n  to stay discoverable.\n  \n  Two provider types exist:\n  \n  - Sweep provider: Divides the DHT keyspace into regions and systematically\n    sweeps through them over the reprovide interval. Batches CIDs allocated\n    to the same DHT servers, reducing lookups from N (one per CID) to a\n    small static number based on DHT size (~3k for 10k DHT servers). Spreads\n    work evenly over time to prevent resource spikes and ensure announcements\n    happen just before records expire.\n  \n  - Legacy provider: Processes each CID individually with separate DHT\n    lookups. Attempts to reprovide all content as quickly as possible at the\n    start of each cycle. Works well for small datasets but struggles with\n    large collections.\n  \n  Learn more:\n  - Config: https://github.com/ipfs/kubo/blob/master/docs/config.md#provide\n  - Metrics: https://github.com/ipfs/kubo/blob/master/docs/provide-stats.md\n  \n  DEFAULT OUTPUT:\n  \n  Shows a brief summary including queue sizes, scheduled items, average record\n  holders, ongoing/total provides, and worker warnings.\n  \n  DETAILED OUTPUT:\n  \n  Use --all for detailed statistics with these sections: connectivity, queues,\n  schedule, timings, network, operations, and workers. Individual sections can\n  be displayed with their flags (e.g., --network, --operations). Multiple flags\n  can be combined.\n  \n  Use --compact for monitoring-friendly 2-column output (requires --all).\n  \n  EXAMPLES:\n  \n  Monitor provider statistics in real-time with 2-column layout:\n  \n    watch ipfs provide stat --all --compact\n  \n  Get statistics in JSON format for programmatic processing:\n  \n    ipfs provide stat --enc=json | jq\n  \n  NOTES:\n  \n  - This interface is experimental and may change between releases\n  - Legacy provider shows basic stats only (no flags supported)\n  - \"Regions\" are keyspace divisions for spreading reprovide work\n  - For Dual DHT: use --lan for LAN provider stats (default is WAN)"
        }
      ],
      "options": [],
      "name": "ipfs provide",
      "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs provide - Control and monitor content providing\n\nSYNOPSIS\n  ipfs provide\n\nDESCRIPTION\n\n  Control providing operations.\n  \n  OVERVIEW:\n  \n  The provider system advertises content by publishing provider records,\n  allowing other nodes to discover which peers have specific content.\n  Content is reprovided periodically (every Provide.DHT.Interval)\n  according to Provide.Strategy.\n  \n  CONFIGURATION:\n  \n  Learn more: https://github.com/ipfs/kubo/blob/master/docs/config.md#provide\n  \n  SEE ALSO:\n  \n  For ad-hoc one-time provide, see 'ipfs routing provide'\n\nEXPERIMENTAL SUBCOMMANDS\n  ipfs provide clear - Clear all CIDs from the provide queue.\n  ipfs provide stat  - Show statistics about the provider system"
    },
    {
      "description": "List links (references) from an object.",
      "subcommands": [
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs refs local",
          "raw_help_text": "USAGE\n  ipfs refs local - List all local references.\n\nSYNOPSIS\n  ipfs refs local\n\nDESCRIPTION\n\n  Displays the hashes of all local objects. NOTE: This treats all local objects as \"raw blocks\" and returns CIDv1-Raw CIDs.",
          "description": "List all local references."
        }
      ],
      "options": [
        {
          "option": "--edges",
          "shortcut": "-e",
          "description": "Emit edge format: `<from> -> <to>`.",
          "value": "bool",
          "default": null
        },
        {
          "option": "--format",
          "shortcut": null,
          "description": "Emit edges with given format. Available tokens: <src> <dst> <linkname>.",
          "value": "string",
          "default": "<dst>"
        },
        {
          "option": "--max-depth",
          "shortcut": null,
          "description": "Only for recursive refs, limits fetch and listing to the given depth.",
          "value": "int",
          "default": "-1"
        },
        {
          "option": "--recursive",
          "shortcut": "-r",
          "description": "Recursively list links of child nodes.",
          "value": "bool",
          "default": null
        },
        {
          "option": "--unique",
          "shortcut": "-u",
          "description": "Omit duplicate refs from output.",
          "value": "bool",
          "default": null
        }
      ],
      "name": "ipfs refs",
      "raw_help_text": "USAGE\n  ipfs refs <ipfs-path>... - List links (references) from an object.\n\nSYNOPSIS\n  ipfs refs [--format=<format>] [--edges | -e] [--unique | -u]\n            [--recursive | -r] [--max-depth=<max-depth>] [--] <ipfs-path>...\n\nARGUMENTS\n\n  <ipfs-path>... - Path to the object(s) to list refs from.\n\nOPTIONS\n\n  --format         string - Emit edges with given format. Available tokens:\n                            <src> <dst> <linkname>. Default: <dst>.\n  -e, --edges      bool   - Emit edge format: `<from> -> <to>`.\n  -u, --unique     bool   - Omit duplicate refs from output.\n  -r, --recursive  bool   - Recursively list links of child nodes.\n  --max-depth      int    - Only for recursive refs, limits fetch and listing\n                            to the given depth. Default: -1.\n\nDESCRIPTION\n\n  Lists the hashes of all the links an IPFS or IPNS object(s) contains,\n  with the following format:\n  \n    <link base58 hash>\n  \n  List all references recursively by using the flag '-r'.\n  \n  NOTE: Like most other commands, Kubo will try to fetch the blocks of the passed path if they can't be found in the local store if it is running in online mode.\n\nSUBCOMMANDS\n  ipfs refs local - List all local references.\n\n  For more information about each command, use:\n  'ipfs refs <subcmd> --help'"
    },
    {
      "description": "Manipulate the IPFS repo.",
      "subcommands": [
        {
          "description": "Perform a garbage collection sweep on the repo.",
          "subcommands": [],
          "options": [
            {
              "option": "--stream-errors",
              "shortcut": null,
              "description": "Stream errors.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--quiet",
              "shortcut": "-q",
              "description": "Write minimal output.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--silent",
              "shortcut": null,
              "description": "Write no output.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs repo gc",
          "raw_help_text": "USAGE\n  ipfs repo gc - Perform a garbage collection sweep on the repo.\n\nSYNOPSIS\n  ipfs repo gc [--stream-errors] [--quiet | -q] [--silent]\n\nOPTIONS\n\n  --stream-errors  bool - Stream errors.\n  -q, --quiet      bool - Write minimal output.\n  --silent         bool - Write no output.\n\nDESCRIPTION\n\n  'ipfs repo gc' is a plumbing command that will sweep the local\n  set of stored objects and remove ones that are not pinned in\n  order to reclaim hard disk space."
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs repo ls",
          "raw_help_text": "USAGE\n  ipfs repo ls - List all local references.\n\nSYNOPSIS\n  ipfs repo ls\n\nDESCRIPTION\n\n  Displays the hashes of all local objects. NOTE: This treats all local objects as \"raw blocks\" and returns CIDv1-Raw CIDs.",
          "description": "List all local references."
        },
        {
          "description": "Apply repository migrations to a specific version.",
          "subcommands": [],
          "options": [
            {
              "option": "--allow-downgrade",
              "shortcut": null,
              "description": "Allow downgrading to a lower repo version.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--to",
              "shortcut": null,
              "description": "Target repository version.",
              "value": "int",
              "default": "18"
            }
          ],
          "name": "ipfs repo migrate",
          "raw_help_text": "USAGE\n  ipfs repo migrate - Apply repository migrations to a specific version.\n\nSYNOPSIS\n  ipfs repo migrate [--to=<to>] [--allow-downgrade]\n\nOPTIONS\n\n  --to               int  - Target repository version. Default: 18.\n  --allow-downgrade  bool - Allow downgrading to a lower repo version.\n\nDESCRIPTION\n\n  'ipfs repo migrate' applies repository migrations to bring the repository\n  to a specific version. By default, migrates to the latest version supported\n  by this IPFS binary.\n  \n  Examples:\n    ipfs repo migrate                # Migrate to latest version\n    ipfs repo migrate --to=17       # Migrate to version 17\n    ipfs repo migrate --to=16 --allow-downgrade  # Downgrade to version 16\n  \n  WARNING: Downgrading a repository may cause data loss and requires using\n  an older IPFS binary that supports the target version. After downgrading,\n  you must use an IPFS implementation compatible with that repository version.\n  \n  Repository versions 16+ use embedded migrations for faster, more reliable\n  migration. Versions below 16 require external migration tools."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--size-only",
              "shortcut": "-s",
              "description": "Only report RepoSize and StorageMax.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--human",
              "shortcut": "-H",
              "description": "Print sizes in human readable format (e.g., 1K 234M 2G).",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs repo stat",
          "raw_help_text": "USAGE\n  ipfs repo stat - Get stats for the currently used repo.\n\nSYNOPSIS\n  ipfs repo stat [--size-only | -s] [--human | -H]\n\nOPTIONS\n\n  -s, --size-only  bool - Only report RepoSize and StorageMax.\n  -H, --human      bool - Print sizes in human readable format (e.g., 1K 234M\n                          2G).\n\nDESCRIPTION\n\n  'ipfs repo stat' provides information about the local set of\n  stored objects. It outputs:\n  \n  RepoSize        int Size in bytes that the repo is currently taking.\n  StorageMax      string Maximum datastore size (from configuration)\n  NumObjects      int Number of objects in the local repo.\n  RepoPath        string The path to the repo being currently used.\n  Version         string The repo version.",
          "description": "Get stats for the currently used repo."
        },
        {
          "name": "ipfs repo verify",
          "subcommands": [],
          "options": [],
          "description": "Verify all blocks in repo are not corrupted."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--quiet",
              "shortcut": "-q",
              "description": "Write minimal output.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs repo version",
          "raw_help_text": "USAGE\n  ipfs repo version - Show the repo version.\n\nSYNOPSIS\n  ipfs repo version [--quiet | -q]\n\nOPTIONS\n\n  -q, --quiet  bool - Write minimal output.\n\nDESCRIPTION\n\n  'ipfs repo version' returns the current repo version.",
          "description": "Show the repo version."
        }
      ],
      "options": [],
      "name": "ipfs repo",
      "raw_help_text": "USAGE\n  ipfs repo - Manipulate the IPFS repo.\n\nSYNOPSIS\n  ipfs repo\n\nDESCRIPTION\n\n  'ipfs repo' is a plumbing command used to manipulate the repo.\n\nSUBCOMMANDS\n  ipfs repo gc      - Perform a garbage collection sweep on the repo.\n  ipfs repo ls      - List all local references.\n  ipfs repo migrate - Apply repository migrations to a specific version.\n  ipfs repo stat    - Get stats for the currently used repo.\n  ipfs repo verify  - Verify all blocks in repo are not corrupted.\n  ipfs repo version - Show the repo version.\n\n  For more information about each command, use:\n  'ipfs repo <subcmd> --help'"
    },
    {
      "command": {
        "description": "Resolve the value of names to IPFS.",
        "subcommands": [
          {
            "name": "resolve",
            "description": "Resolve the value of names to IPFS."
          }
        ],
        "options": [
          {
            "option": "--dht-record-count",
            "shortcut": "--dhtrc",
            "description": "Number of records to request for DHT resolution.",
            "value": "<dht-record-count>",
            "default": null
          },
          {
            "option": "--dht-timeout",
            "shortcut": "--dhtt",
            "description": "Max time to collect values during DHT resolution e.g. \"30s\". Pass 0 for no timeout.",
            "value": "<dht-timeout>",
            "default": null
          },
          {
            "option": "--recursive",
            "shortcut": "-r",
            "description": "Resolve until the result is an IPFS name. Default: true.",
            "value": "bool",
            "default": "true"
          }
        ]
      },
      "name": "ipfs resolve",
      "raw_help_text": "USAGE\n  ipfs resolve <name> - Resolve the value of names to IPFS.\n\nSYNOPSIS\n  ipfs resolve [--recursive=false]\n               [--dht-record-count=<dht-record-count> | --dhtrc]\n               [--dht-timeout=<dht-timeout> | --dhtt] [--] <name>\n\nARGUMENTS\n\n  <name> - The name to resolve.\n\nOPTIONS\n\n  -r, --recursive              bool   - Resolve until the result is an IPFS\n                                        name. Default: true.\n  --dhtrc, --dht-record-count  int    - Number of records to request for DHT\n                                        resolution.\n  --dhtt, --dht-timeout        string - Max time to collect values during DHT\n                                        resolution e.g. \"30s\". Pass 0 for no\n                                        timeout.\n\nDESCRIPTION\n\n  There are a number of mutable name protocols that can link among\n  themselves and into IPNS. For example IPNS references can (currently)\n  point at an IPFS object, and DNS links can point at other DNS links, IPNS\n  entries, or IPFS objects. This command accepts any of these\n  identifiers and resolves them to the referenced item.\n  \n  EXAMPLES\n  \n  Resolve the value of your identity:\n  \n    $ ipfs resolve /ipns/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    /ipfs/Qmcqtw8FfrVSBaRmbWwHxt3AuySBhJLcvmFYi3Lbc4xnwj\n  \n  Resolve the value of another name:\n  \n    $ ipfs resolve /ipns/QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n\n    /ipns/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Resolve the value of another name recursively:\n  \n    $ ipfs resolve -r /ipns/QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n\n    /ipfs/Qmcqtw8FfrVSBaRmbWwHxt3AuySBhJLcvmFYi3Lbc4xnwj\n  \n  Resolve the value of an IPFS DAG path:\n  \n    $ ipfs resolve /ipfs/QmeZy1fGbwgVSrqbfh9fKQrAWgeyRnj7h8fsHS1oy3k99x/beep/boop\n    /ipfs/QmYRMjyvAiHKN9UTi8Bzt1HUspmSRD8T8DwxfSMzLgBon1",
      "subcommands": [],
      "description": "Resolve any type of content path"
    },
    {
      "description": "Issue routing commands.",
      "subcommands": [
        {
          "subcommands": [],
          "options": [
            {
              "option": "--verbose",
              "shortcut": "-v",
              "description": "Print extra information.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs routing findpeer",
          "raw_help_text": "USAGE\n  ipfs routing findpeer <peerID>... - Find the multiaddresses associated with a\n                                      Peer ID.\n\nSYNOPSIS\n  ipfs routing findpeer [--verbose | -v] [--] <peerID>...\n\nARGUMENTS\n\n  <peerID>... - The ID of the peer to search for.\n\nOPTIONS\n\n  -v, --verbose  bool - Print extra information.\n\nDESCRIPTION\n\n  Outputs a list of newline-delimited multiaddresses.",
          "description": "Find the multiaddresses associated with a Peer ID."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--verbose",
              "shortcut": "-v",
              "description": "Print extra information.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--num-providers",
              "shortcut": "-n",
              "description": "The number of providers to find.",
              "value": "int",
              "default": "20"
            }
          ],
          "name": "ipfs routing findprovs",
          "raw_help_text": "USAGE\n  ipfs routing findprovs <key>... - Find peers that can provide a specific\n                                    value, given a key.\n\nSYNOPSIS\n  ipfs routing findprovs [--verbose | -v] [--num-providers=<num-providers> | -n]\n                         [--] <key>...\n\nARGUMENTS\n\n  <key>... - The key to find providers for.\n\nOPTIONS\n\n  -v, --verbose        bool - Print extra information.\n  -n, --num-providers  int  - The number of providers to find. Default: 20.\n\nDESCRIPTION\n\n  Outputs a list of newline-delimited provider Peer IDs.",
          "description": "Find peers that can provide a specific value, given a key."
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs routing get",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs routing get <key>... - Given a key, query the routing system for its\n                              best value.\n\nSYNOPSIS\n  ipfs routing get [--] <key>...\n\nARGUMENTS\n\n  <key>... - The key to find a value for.\n\nDESCRIPTION\n\n  Outputs the best value for the given key.\n  \n  There may be several different values for a given key stored in the routing\n  system; in this context 'best' means the record that is most desirable. There is\n  no one metric for 'best': it depends entirely on the key type. For IPNS, 'best'\n  is the record that is both valid and has the highest sequence number (freshest).\n  Different key types can specify other 'best' rules.",
          "description": "Given a key, query the routing system for its best value."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--recursive",
              "shortcut": "-r",
              "description": "Recursively provide entire graph.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--verbose",
              "shortcut": "-v",
              "description": "Print extra information.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs routing provide",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs routing provide <key>... - Announce to the network that you are\n                                  providing given values.\n\nSYNOPSIS\n  ipfs routing provide [--verbose | -v] [--recursive | -r] [--] <key>...\n\nARGUMENTS\n\n  <key>... - The key[s] to send provide records for.\n\nOPTIONS\n\n  -v, --verbose    bool - Print extra information.\n  -r, --recursive  bool - Recursively provide entire graph.",
          "description": "Announce to the network that you are providing given values."
        },
        {
          "description": "Write a key/value pair to the routing system.",
          "subcommands": [],
          "options": [
            {
              "option": "--allow-offline",
              "shortcut": null,
              "description": "When offline, save the IPNS record to the local datastore without broadcasting to the network instead of simply failing.",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs routing put",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs routing put <key> <value-file> - Write a key/value pair to the routing\n                                        system.\n\nSYNOPSIS\n  ipfs routing put [--allow-offline] [--] <key> <value-file>\n\nARGUMENTS\n\n  <key>        - The key to store the value at.\n  <value-file> - A path to a file containing the value to store.\n\nOPTIONS\n\n  --allow-offline  bool - When offline, save the IPNS record to the local\n                          datastore without broadcasting to the network instead\n                          of simply failing.\n\nDESCRIPTION\n\n  Given a key of the form /foo/bar and a valid value for that key, this will write\n  that value to the routing system with that key.\n  \n  Keys have two parts: a keytype (foo) and the key name (bar). IPNS uses the\n  /ipns keytype, and expects the key name to be a Peer ID. IPNS entries are\n  specifically formatted (protocol buffer).\n  \n  You may only use keytypes that are supported in your ipfs binary: currently\n  this is only /ipns. Unless you have a relatively deep understanding of the\n  go-ipfs routing internals, you likely want to be using 'ipfs name publish' instead\n  of this.\n  \n  The value must be a valid value for the given key type. For example, if the key\n  is /ipns/QmFoo, the value must be IPNS record (protobuf) signed with the key\n  identified by QmFoo."
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs routing reprovide",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs routing reprovide - Trigger reprovider.\n\nSYNOPSIS\n  ipfs routing reprovide\n\nDESCRIPTION\n\n  Trigger reprovider to announce our data to network.",
          "description": "Trigger reprovider."
        }
      ],
      "options": [],
      "name": "ipfs routing",
      "raw_help_text": "USAGE\n  ipfs routing - Issue routing commands.\n\n  ipfs routing\n\nSUBCOMMANDS\n  ipfs routing findpeer <peerID>... - Find the multiaddresses associated with a\n                                      Peer ID.\n  ipfs routing findprovs <key>...   - Find peers that can provide a specific\n                                      value, given a key.\n\n  For more information about each command, use:\n  'ipfs routing <subcmd> --help'\n\nEXPERIMENTAL SUBCOMMANDS\n  ipfs routing get <key>...           - Given a key, query the routing system\n                                        for its best value.\n  ipfs routing provide <key>...       - Announce to the network that you are\n                                        providing given values.\n  ipfs routing put <key> <value-file> - Write a key/value pair to the routing\n                                        system.\n  ipfs routing reprovide              - Trigger reprovider."
    },
    {
      "subcommands": [],
      "options": [],
      "name": "ipfs shutdown",
      "raw_help_text": "USAGE\n  ipfs shutdown - Shut down the IPFS daemon.\n\nSYNOPSIS\n  ipfs shutdown",
      "description": "Shut down the daemon process"
    },
    {
      "description": "Query IPFS statistics.",
      "subcommands": [
        {
          "subcommands": [],
          "options": [
            {
              "option": "--verbose",
              "shortcut": "-v",
              "description": "Print extra information.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--human",
              "shortcut": null,
              "description": "Print sizes in human readable format (e.g., 1K 234M 2G).",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs stats bitswap",
          "raw_help_text": "USAGE\n  ipfs stats bitswap - Show some diagnostic information on the bitswap agent.\n\nSYNOPSIS\n  ipfs stats bitswap [--verbose | -v] [--human]\n\nOPTIONS\n\n  -v, --verbose  bool - Print extra information.\n  --human        bool - Print sizes in human readable format (e.g., 1K 234M 2G).",
          "description": "Show some diagnostic information on the bitswap agent."
        },
        {
          "description": "Print IPFS bandwidth information.",
          "subcommands": [],
          "options": [
            {
              "option": "--interval",
              "shortcut": "-i",
              "description": "Time interval to wait between updating output, if 'poll' is true.",
              "value": "<interval>",
              "default": "1s"
            },
            {
              "option": "--peer",
              "shortcut": "-p",
              "description": "Specify a peer to print bandwidth for.",
              "value": "string",
              "default": null
            },
            {
              "option": "--poll",
              "shortcut": null,
              "description": "Print bandwidth at an interval.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--proto",
              "shortcut": "-t",
              "description": "Specify a protocol to print bandwidth for.",
              "value": "string",
              "default": null
            }
          ],
          "name": "ipfs stats bw",
          "raw_help_text": "USAGE\n  ipfs stats bw - Print IPFS bandwidth information.\n\nSYNOPSIS\n  ipfs stats bw [--peer=<peer> | -p] [--proto=<proto> | -t] [--poll]\n                [--interval=<interval> | -i]\n\nOPTIONS\n\n  -p, --peer      string - Specify a peer to print bandwidth for.\n  -t, --proto     string - Specify a protocol to print bandwidth for.\n  --poll          bool   - Print bandwidth at an interval.\n  -i, --interval  string - Time interval to wait between updating output, if\n                           'poll' is true.\n  \n      This accepts durations such as\n                           \"300s\", \"1.5h\" or \"2h45m\". Valid time units are:\n     \n                           \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\", \"h\". Default:\n                           1s.\n\nDESCRIPTION\n\n  'ipfs stats bw' prints bandwidth information for the ipfs daemon.\n  It displays: TotalIn, TotalOut, RateIn, RateOut.\n  \n  By default, overall bandwidth and all protocols are shown. To limit bandwidth\n  to a particular peer, use the 'peer' option along with that peer's multihash\n  id. To specify a specific protocol, use the 'proto' option. The 'peer' and\n  'proto' options cannot be specified simultaneously. The protocols that are\n  queried using this method are outlined in the specification:\n  https://github.com/libp2p/specs/blob/master/_archive/7-properties.md#757-protocol-multicodecs\n  \n  Example protocol options:\n    - /ipfs/id/1.0.0\n    - /ipfs/bitswap\n    - /ipfs/dht\n  \n  Example:\n  \n      > ipfs stats bw -t /ipfs/bitswap\n      Bandwidth\n      TotalIn: 5.0MB\n      TotalOut: 0B\n      RateIn: 343B/s\n      RateOut: 0B/s\n      > ipfs stats bw -p QmepgFW7BHEtU4pZJdxaNiv75mKLLRQnPi1KaaXmQN4V1a\n      Bandwidth\n      TotalIn: 4.9MB\n      TotalOut: 12MB\n      RateIn: 0B/s\n      RateOut: 0B/s"
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs stats dht",
          "raw_help_text": "USAGE\n  ipfs stats dht [<dht>]... - Returns statistics about the node's DHT(s).\n\nSYNOPSIS\n  ipfs stats dht [--] [<dht>...]\n\nARGUMENTS\n\n  [<dht>]... - The DHT whose table should be listed (wanserver, lanserver, wan,\n               lan). wan and lan refer to client routing tables. When using the\n               experimental DHT client only WAN is supported. Defaults to wan\n               and lan.\n\nDESCRIPTION\n\n  Returns statistics about the DHT(s) the node is participating in.\n  \n  This interface is not stable and may change from release to release.",
          "description": "Returns statistics about the node's DHT(s)."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--size-only",
              "shortcut": "-s",
              "description": "Only report RepoSize and StorageMax.",
              "value": "bool",
              "default": null
            },
            {
              "option": "--human",
              "shortcut": "-H",
              "description": "Print sizes in human readable format (e.g., 1K 234M 2G).",
              "value": "bool",
              "default": null
            }
          ],
          "name": "ipfs stats repo",
          "raw_help_text": "USAGE\n  ipfs stats repo - Get stats for the currently used repo.\n\nSYNOPSIS\n  ipfs stats repo [--size-only | -s] [--human | -H]\n\nOPTIONS\n\n  -s, --size-only  bool - Only report RepoSize and StorageMax.\n  -H, --human      bool - Print sizes in human readable format (e.g., 1K 234M\n                          2G).\n\nDESCRIPTION\n\n  'ipfs repo stat' provides information about the local set of\n  stored objects. It outputs:\n  \n  RepoSize        int Size in bytes that the repo is currently taking.\n  StorageMax      string Maximum datastore size (from configuration)\n  NumObjects      int Number of objects in the local repo.\n  RepoPath        string The path to the repo being currently used.\n  Version         string The repo version.",
          "description": "Get stats for the currently used repo."
        }
      ],
      "options": [],
      "name": "ipfs stats",
      "raw_help_text": "USAGE\n  ipfs stats - Query IPFS statistics.\n\nSYNOPSIS\n  ipfs stats\n\nDESCRIPTION\n\n  'ipfs stats' is a set of commands to help look at statistics\n  for your IPFS node.\n\nSUBCOMMANDS\n  ipfs stats bitswap        - Show some diagnostic information on the bitswap\n                              agent.\n  ipfs stats bw             - Print IPFS bandwidth information.\n  ipfs stats dht [<dht>]... - Returns statistics about the node's DHT(s).\n  ipfs stats repo           - Get stats for the currently used repo.\n\n  For more information about each command, use:\n  'ipfs stats <subcmd> --help'\n\nDEPRECATED SUBCOMMANDS\n  ipfs stats provide   - Deprecated command, use 'ipfs provide stat' instead.\n  ipfs stats reprovide - Deprecated command, use 'ipfs provide stat' instead."
    },
    {
      "description": "Interact with the swarm.",
      "subcommands": [
        {
          "subcommands": [
            {
              "subcommands": [],
              "options": [],
              "name": "ipfs swarm addrs listen",
              "raw_help_text": "USAGE\n  ipfs swarm addrs listen - List interface listening addresses.\n\nSYNOPSIS\n  ipfs swarm addrs listen\n\nDESCRIPTION\n\n  'ipfs swarm addrs listen' lists all interface addresses the node is listening on.",
              "description": "List interface listening addresses."
            },
            {
              "subcommands": [],
              "options": [
                {
                  "option": "--id",
                  "shortcut": "-",
                  "description": "Show peer ID in addresses.",
                  "value": "bool",
                  "default": null
                }
              ],
              "description": "Lists all local listening addresses announced to the network.",
              "name": "ipfs swarm addrs local",
              "raw_help_text": "USAGE\n  ipfs swarm addrs local - List local addresses.\n\nSYNOPSIS\n  ipfs swarm addrs local [--id]\n\nOPTIONS\n\n  --id  bool - Show peer ID in addresses.\n\nDESCRIPTION\n\n  'ipfs swarm addrs local' lists all local listening addresses announced to the network."
            }
          ],
          "options": [],
          "name": "ipfs swarm addrs",
          "raw_help_text": "USAGE\n  ipfs swarm addrs - List known addresses. Useful for debugging.\n\nSYNOPSIS\n  ipfs swarm addrs\n\nDESCRIPTION\n\n  'ipfs swarm addrs' lists all addresses this node is aware of.\n\nSUBCOMMANDS\n  ipfs swarm addrs listen - List interface listening addresses.\n  ipfs swarm addrs local  - List local addresses.\n\n  For more information about each command, use:\n  'ipfs swarm addrs <subcmd> --help'",
          "description": "List known addresses. Useful for debugging."
        },
        {
          "description": "Open connection to a given peer.",
          "subcommands": [],
          "options": [],
          "name": "ipfs swarm connect",
          "raw_help_text": "USAGE\n  ipfs swarm connect <address>... - Open connection to a given peer.\n\nSYNOPSIS\n  ipfs swarm connect [--] <address>...\n\nARGUMENTS\n\n  <address>... - Address of peer to connect to.\n\nDESCRIPTION\n\n  'ipfs swarm connect' attempts to ensure a connection to a given peer.\n  \n  Multiaddresses given are advisory, for example the node may already be aware of other addresses for a given peer or may already have an established connection to the peer.\n  \n  The address format is a libp2p multiaddr:\n  \n  ipfs swarm connect /ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ"
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs swarm disconnect",
          "raw_help_text": "USAGE\n  ipfs swarm disconnect <address>... - Close connection to a given address.\n\nSYNOPSIS\n  ipfs swarm disconnect [--] <address>...\n\nARGUMENTS\n\n  <address>... - Address of peer to disconnect from.\n\nDESCRIPTION\n\n  'ipfs swarm disconnect' closes a connection to a peer address. The address\n  format is an IPFS multiaddr:\n  \n  ipfs swarm disconnect /ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ\n  \n  The disconnect is not permanent; if ipfs needs to talk to that address later,\n  it will reconnect.",
          "description": "Close connection to a given address."
        },
        {
          "description": "Manipulate address filters.",
          "subcommands": [
            {
              "subcommands": [],
              "options": [],
              "name": "ipfs swarm filters add",
              "raw_help_text": "USAGE\n  ipfs swarm filters add <address>... - Add an address filter.\n\nSYNOPSIS\n  ipfs swarm filters add [--] <address>...\n\nARGUMENTS\n\n  <address>... - Multiaddr to filter.\n\nDESCRIPTION\n\n  'ipfs swarm filters add' will add an address filter to the daemons swarm.",
              "description": "Add an address filter."
            },
            {
              "subcommands": [],
              "options": [],
              "name": "ipfs swarm filters rm",
              "raw_help_text": "USAGE\n  ipfs swarm filters rm <address>... - Remove an address filter.\n\nSYNOPSIS\n  ipfs swarm filters rm [--] <address>...\n\nARGUMENTS\n\n  <address>... - Multiaddr filter to remove.\n\nDESCRIPTION\n\n  'ipfs swarm filters rm' will remove an address filter from the daemons swarm.",
              "description": "Remove an address filter."
            }
          ],
          "options": [],
          "name": "ipfs swarm filters",
          "raw_help_text": "USAGE\n  ipfs swarm filters - Manipulate address filters.\n\nSYNOPSIS\n  ipfs swarm filters\n\nDESCRIPTION\n\n  'ipfs swarm filters' will list out currently applied filters. Its subcommands\n  can be used to add or remove said filters. Filters are specified using the\n  multiaddr-filter format:\n  \n  Example:\n  \n      /ip4/192.168.0.0/ipcidr/16\n  \n  Where the above is equivalent to the standard CIDR:\n  \n      192.168.0.0/16\n  \n  Filters default to those specified under the \"Swarm.AddrFilters\" config key.\n\nSUBCOMMANDS\n  ipfs swarm filters add <address>... - Add an address filter.\n  ipfs swarm filters rm <address>...  - Remove an address filter.\n\n  For more information about each command, use:\n  'ipfs swarm filters <subcmd> --help'"
        },
        {
          "subcommands": [
            {
              "subcommands": [],
              "options": [],
              "name": "ipfs swarm peering add",
              "raw_help_text": "USAGE\n  ipfs swarm peering add <address>... - Add peers into the peering subsystem.\n\nSYNOPSIS\n  ipfs swarm peering add [--] <address>...\n\nARGUMENTS\n\n  <address>... - address of peer to add into the peering subsystem\n\nDESCRIPTION\n\n  'ipfs swarm peering add' will add the new address to the peering subsystem as one that should always be connected to.",
              "description": "Add peers into the peering subsystem."
            },
            {
              "subcommands": [],
              "options": [],
              "name": "ipfs swarm peering ls",
              "raw_help_text": "USAGE\n  ipfs swarm peering ls - List peers registered in the peering subsystem.\n\nSYNOPSIS\n  ipfs swarm peering ls\n\nDESCRIPTION\n\n  'ipfs swarm peering ls' lists the peers that are registered in the peering subsystem and to which the daemon is always connected.",
              "description": "List peers registered in the peering subsystem."
            },
            {
              "subcommands": [],
              "options": [],
              "name": "ipfs swarm peering rm",
              "raw_help_text": "USAGE\n  ipfs swarm peering rm <ID>... - Remove a peer from the peering subsystem.\n\nSYNOPSIS\n  ipfs swarm peering rm [--] <ID>...\n\nARGUMENTS\n\n  <ID>... - ID of peer to remove from the peering subsystem\n\nDESCRIPTION\n\n  'ipfs swarm peering rm' will remove the given ID from the peering subsystem and remove it from the always-on connection.",
              "description": "Remove a peer from the peering subsystem."
            }
          ],
          "options": [],
          "name": "ipfs swarm peering",
          "raw_help_text": "USAGE\n  ipfs swarm peering - Modify the peering subsystem.\n\nSYNOPSIS\n  ipfs swarm peering\n\nDESCRIPTION\n\n  'ipfs swarm peering' manages the peering subsystem.\n  Peers in the peering subsystem are maintained to be connected, reconnected\n  on disconnect with a back-off.\n  The changes are not saved to the config.\n\nSUBCOMMANDS\n  ipfs swarm peering add <address>... - Add peers into the peering subsystem.\n  ipfs swarm peering ls               - List peers registered in the peering\n                                        subsystem.\n  ipfs swarm peering rm <ID>...       - Remove a peer from the peering\n                                        subsystem.\n\n  For more information about each command, use:\n  'ipfs swarm peering <subcmd> --help'",
          "description": "Modify the peering subsystem."
        },
        {
          "subcommands": [],
          "options": [
            {
              "option": "--direction",
              "shortcut": "-",
              "description": "Also list information about the direction of connection.",
              "value": null,
              "default": null
            },
            {
              "option": "--identify",
              "shortcut": "-",
              "description": "Also list information about peers identify.",
              "value": null,
              "default": null
            },
            {
              "option": "--latency",
              "shortcut": "-",
              "description": "Also list information about latency to each peer.",
              "value": null,
              "default": null
            },
            {
              "option": "--streams",
              "shortcut": "-",
              "description": "Also list information about open streams for each peer.",
              "value": null,
              "default": null
            },
            {
              "option": "--verbose",
              "shortcut": "-v",
              "description": "display all extra information.",
              "value": null,
              "default": null
            }
          ],
          "name": "ipfs swarm peers",
          "raw_help_text": "USAGE\n  ipfs swarm peers - List peers with open connections.\n\nSYNOPSIS\n  ipfs swarm peers [--verbose | -v] [--streams] [--latency] [--direction]\n                   [--identify]\n\nOPTIONS\n\n  -v, --verbose  bool - display all extra information.\n  --streams      bool - Also list information about open streams for each peer.\n  --latency      bool - Also list information about latency to each peer.\n  --direction    bool - Also list information about the direction of connection.\n  --identify     bool - Also list information about peers identify.\n\nDESCRIPTION\n\n  'ipfs swarm peers' lists the set of peers this node is connected to.",
          "description": "List peers with open connections."
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs swarm resources",
          "raw_help_text": "WARNING:   EXPERIMENTAL, command may change in future releases\n\nUSAGE\n  ipfs swarm resources - Get a summary of all resources accounted for by the\n                         libp2p Resource Manager.\n\nSYNOPSIS\n  ipfs swarm resources\n\nDESCRIPTION\n\n  Get a summary of all resources accounted for by the libp2p Resource Manager.\n  This includes the limits and the usage against those limits.\n  This can output a human readable table and JSON encoding.",
          "description": "Get a summary of all resources accounted for by the libp2p Resource Manager."
        }
      ],
      "options": [],
      "name": "ipfs swarm",
      "raw_help_text": "USAGE\n  ipfs swarm - Interact with the swarm.\n\nSYNOPSIS\n  ipfs swarm\n\nDESCRIPTION\n\n  'ipfs swarm' is a tool to manipulate the network swarm. The swarm is the\n  component that opens, listens for, and maintains connections to other\n  ipfs peers in the internet.\n\nSUBCOMMANDS\n  ipfs swarm addrs                   - List known addresses. Useful for\n                                       debugging.\n  ipfs swarm connect <address>...    - Open connection to a given peer.\n  ipfs swarm disconnect <address>... - Close connection to a given address.\n  ipfs swarm filters                 - Manipulate address filters.\n  ipfs swarm peering                 - Modify the peering subsystem.\n  ipfs swarm peers                   - List peers with open connections.\n\n  For more information about each command, use:\n  'ipfs swarm <subcmd> --help'\n\nEXPERIMENTAL SUBCOMMANDS\n  ipfs swarm resources - Get a summary of all resources accounted for by the\n                         libp2p Resource Manager."
    },
    {
      "name": "ipfs timeout",
      "subcommands": [],
      "options": [],
      "description": "Set a global timeout on the command"
    },
    {
      "subcommands": [],
      "options": [],
      "name": "ipfs update",
      "raw_help_text": "ipfs-update is an 'external' command.\nIt does not currently appear to be installed.\nPlease see https://github.com/ipfs/ipfs-update/blob/master/README.md#install for installation instructions.",
      "description": "Download and apply go-ipfs updates"
    },
    {
      "description": "Returns the current version of IPFS and exits.",
      "subcommands": [
        {
          "subcommands": [],
          "options": [
            {
              "option": "--min-percent",
              "shortcut": "-t",
              "description": "Percentage (1-100) of sampled peers with the new Kubo version needed to trigger an update warning.",
              "value": "int",
              "default": "5"
            }
          ],
          "name": "ipfs version check",
          "raw_help_text": "USAGE\n  ipfs version check - Checks Kubo version against connected peers.\n\nSYNOPSIS\n  ipfs version check [--min-percent=<min-percent> | -t]\n\nOPTIONS\n\n  -t, --min-percent  int - Percentage (1-100) of sampled peers with the new\n                           Kubo version needed to trigger an update warning.\n                           Default: 5.\n\nDESCRIPTION\n\n  This command uses the libp2p identify protocol to check the 'AgentVersion'\n  of connected peers and see if the Kubo version we're running is outdated.\n  \n  Peers with an AgentVersion that doesn't start with 'kubo/' are ignored.\n  'UpdateAvailable' is set to true only if the 'min-fraction' criteria are met.\n  \n  The 'ipfs daemon' does the same check regularly and logs when a new version\n  is available. You can stop these regular checks by setting\n  Version.SwarmCheckEnabled:false in the config.",
          "description": "Checks Kubo version against connected peers."
        },
        {
          "subcommands": [],
          "options": [],
          "name": "ipfs version deps",
          "raw_help_text": "USAGE\n  ipfs version deps - Shows information about dependencies used for build.\n\nSYNOPSIS\n  ipfs version deps\n\nDESCRIPTION\n\n  Print out all dependencies and their versions.",
          "description": "Shows information about dependencies used for build."
        }
      ],
      "options": [
        {
          "option": "--number",
          "shortcut": "-n",
          "description": "Only show the version number.",
          "value": "bool",
          "default": null
        },
        {
          "option": "--commit",
          "shortcut": null,
          "description": "Show the commit hash.",
          "value": "bool",
          "default": null
        },
        {
          "option": "--repo",
          "shortcut": null,
          "description": "Show repo version.",
          "value": "bool",
          "default": null
        },
        {
          "option": "--all",
          "shortcut": null,
          "description": "Show all version information.",
          "value": "bool",
          "default": null
        }
      ],
      "name": "ipfs version",
      "raw_help_text": "USAGE\n  ipfs version - Show IPFS version information.\n\nSYNOPSIS\n  ipfs version [--number | -n] [--commit] [--repo] [--all]\n\nOPTIONS\n\n  -n, --number  bool - Only show the version number.\n  --commit      bool - Show the commit hash.\n  --repo        bool - Show repo version.\n  --all         bool - Show all version information.\n\nDESCRIPTION\n\n  Returns the current version of IPFS and exits.\n\nSUBCOMMANDS\n  ipfs version check - Checks Kubo version against connected peers.\n  ipfs version deps  - Shows information about dependencies used for build.\n\n  For more information about each command, use:\n  'ipfs version <subcmd> --help'"
    }
  ],
  "options": [
    {
      "option": "--api",
      "shortcut": null,
      "description": "Use a specific API instance (defaults to /ip4/127.0.0.1/tcp/5001)",
      "value": "<api>",
      "default": null
    },
    {
      "option": "--api-auth",
      "shortcut": null,
      "description": "Optional RPC API authorization secret (defined as AuthSecret in API.Authorizations config)",
      "value": "<api-auth>",
      "default": null
    },
    {
      "option": "--cid-base",
      "shortcut": null,
      "description": "Multibase encoding used for version 1 CIDs in output",
      "value": "<base>",
      "default": null
    },
    {
      "option": "--config-file",
      "shortcut": null,
      "description": "Path to the configuration file to use",
      "value": "<config>",
      "default": null
    },
    {
      "option": "--debug",
      "shortcut": "-D",
      "description": "Operate in debug mode",
      "value": null,
      "default": null
    },
    {
      "option": "--encoding",
      "shortcut": "--enc",
      "description": "The encoding type the output should be encoded with (json, xml, or text). Default: text.",
      "value": "<encoding>",
      "default": "text"
    },
    {
      "option": "--help",
      "shortcut": "-h",
      "description": "Show the full command help text",
      "value": null,
      "default": null
    },
    {
      "option": "--local",
      "shortcut": "-L",
      "description": "Run the command locally, instead of using the daemon. DEPRECATED: use --offline",
      "value": null,
      "default": null
    },
    {
      "option": "--offline",
      "shortcut": null,
      "description": "Run the command offline",
      "value": null,
      "default": null
    },
    {
      "option": "--repo-dir",
      "shortcut": null,
      "description": "Path to the repository directory to use",
      "value": "string",
      "default": null
    },
    {
      "option": "--stream-channels",
      "shortcut": null,
      "description": "Stream channel output",
      "value": null,
      "default": null
    },
    {
      "option": "--timeout",
      "shortcut": null,
      "description": "Set a global timeout on the command",
      "value": "<timeout>",
      "default": null
    },
    {
      "option": "-c",
      "shortcut": "--config",
      "description": "[DEPRECATED] Path to the configuration file to use",
      "value": "<config>",
      "default": null
    },
    {
      "option": "--upgrade-cidv0-in-output",
      "shortcut": null,
      "description": "Upgrade version 0 to version 1 CIDs in output",
      "value": null,
      "default": null
    }
  ],
  "name": "ipfs",
  "raw_help_text": "USAGE\n  ipfs  - Global p2p merkle-dag filesystem.\n\nSYNOPSIS\n  ipfs [--config=<config> | -c] [--debug | -D] [--help] [-h] [--api=<api>] [--offline] [--cid-base=<base>] [--upgrade-cidv0-in-output] [--encoding=<encoding> | --enc] [--timeout=<timeout>] <command> ...\n\nOPTIONS\n\n  --repo-dir                 string - Path to the repository directory to use.\n  --config-file              string - Path to the configuration file to use.\n  -c, --config               string - [DEPRECATED] Path to the configuration\n                                      file to use.\n  -D, --debug                bool   - Operate in debug mode.\n  --help                     bool   - Show the full command help text.\n  -h                         bool   - Show a short version of the command help\n                                      text.\n  -L, --local                bool   - Run the command locally, instead of using\n                                      the daemon. DEPRECATED: use --offline.\n  --offline                  bool   - Run the command offline.\n  --api                      string - Use a specific API instance (defaults to\n                                      /ip4/127.0.0.1/tcp/5001).\n  --api-auth                 string - Optional RPC API authorization secret\n                                      (defined as AuthSecret in\n                                      API.Authorizations config).\n  --cid-base                 string - Multibase encoding used for version 1\n                                      CIDs in output.\n  --upgrade-cidv0-in-output  bool   - Upgrade version 0 to version 1 CIDs in\n                                      output.\n  --enc, --encoding          string - The encoding type the output should be\n                                      encoded with (json, xml, or text).\n                                      Default: text.\n  --stream-channels          bool   - Stream channel output.\n  --timeout                  string - Set a global timeout on the command.\n\nSUBCOMMANDS\n  BASIC COMMANDS\n    init          Initialize local IPFS configuration\n    add <path>    Add a file to IPFS\n    cat <ref>     Show IPFS object data\n    get <ref>     Download IPFS objects\n    ls <ref>      List links from an object\n    refs <ref>    List hashes of links from an object\n  \n  DATA STRUCTURE COMMANDS\n    dag           Interact with IPLD DAG nodes\n    files         Interact with files as if they were a unix filesystem\n    block         Interact with raw blocks in the datastore\n  \n  TEXT ENCODING COMMANDS\n    cid           Convert and discover properties of CIDs\n    multibase     Encode and decode data with Multibase format\n  \n  ADVANCED COMMANDS\n    daemon        Start a long-running daemon process\n    shutdown      Shut down the daemon process\n    resolve       Resolve any type of content path\n    name          Publish and resolve IPNS names\n    key           Create and list IPNS name keypairs\n    pin           Pin objects to local storage\n    repo          Manipulate the IPFS repository\n    stats         Various operational stats\n    p2p           Libp2p stream mounting (experimental)\n    filestore     Manage the filestore (experimental)\n    mount         Mount an IPFS read-only mount point (experimental)\n    provide       Control providing operations\n  \n  NETWORK COMMANDS\n    id            Show info about IPFS peers\n    bootstrap     Add or remove bootstrap peers\n    swarm         Manage connections to the p2p network\n    dht           Query the DHT for values or peers\n    routing       Issue routing commands\n    ping          Measure the latency of a connection\n    bitswap       Inspect bitswap state\n    pubsub        Send and receive messages via pubsub\n  \n  TOOL COMMANDS\n    config        Manage configuration\n    version       Show IPFS version information\n    diag          Generate diagnostic reports\n    update        Download and apply go-ipfs updates\n    commands      List all available commands\n    log           Manage and show logs of running daemon\n  \n  Use 'ipfs <command> --help' to learn more about each command.\n  \n  ipfs uses a repository in the local file system. By default, the repo is\n  located at ~/.ipfs. To change the repo location, set the $IPFS_PATH\n  environment variable:\n  \n    export IPFS_PATH=/path/to/ipfsrepo\n  \n  EXIT STATUS\n  \n  The CLI will exit with one of the following values:\n  \n  0     Successful execution.\n  1     Failed executions.\n\n  For more information about each command, use:\n  'ipfs <subcmd> --help'",
  "version": null
}